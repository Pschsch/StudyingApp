package ru.pschsch.pschschapps.studyingapp;
/***********************************Инфа с технострима по работе с данными*********************************************************/
/*Работа с файлами:
* 3 способа работы с ними: assets, internal и external storage
* Assets - файлы, которые предоставляются с приложением. Хранятся в специальной директории assets. Плюсы ассетов: идут сразу с
* приложением и всегда есть в наличии. Минусы: идут с приложением(увеличение веса), нельзя модифицировать. Для раюоты с ними
* используется AssetManager. Через метод open() файл загоняется в InputStream, читаем и возвращаем его. Это, своего рода,
* read-only storage.
* Internal Storage: storage android разбит на два подраздела - internal и external storage.
* Его размер небольшой, место надо экономить. Изначально файлов в нем нет, их нужно переносить в internal storage. Он всегда доступен
* У приложения есть несколько директорий в этом хранилище: директория кэша и директория файлов. Отличаются тем, что директория
* файлов, при записи туда чего-либо, они там будут храниться всегда. В кэш-директории хранятся маловажные файлы(кэш) - при недостатке
* места на Android-устройстве, система пробегается по кэш-директориям приложения и удаляет оттуда всю информацию. Т.е, нужно быть
* готовым к тому, что кэш приложения может быть удален, поэтому файлы, без которых приложение не сможет функционировать, там
* находиться не должны!!! Доступ к директориям internal storage риложения осуществялется с помощью методов
* getCacheDir() и getFilesDir() , применимые к объекту контекста. Отличный вариант использование кэша - кэширование крупных картинок,
* Метод getFilesStreamPath() возвращает сразу InputStream.
* External Storage - на некоторых устройствах его нет, на некотрых он является частью внутренней памяти(на тех, у которых нет слота
* под SD-карту). External Storage доступен не всегда, так как на устройствах, где поддерживается SD-карта, пользователь ее может
* вытащить и дело с концом, приложение полетело. При подключении телефона по USB к ПК, если ExternalStorage азбит на микросхеме
* памяти телефона, доступ к этому хранилищу ограничивается телефон переходит в режим unmounted. Т.е нельзя на него прочесть и записать
* Если идет доступ к данным из этого хранилища, необходимо всегда проверять его статус с помощью метода класса Enviroment
* getExternalStorageState() на статус MEDIA_MOUNTED. Самое главное преимущество такого хранилища - оно очень большое. Обычно,
* производители выделяют под internal Storage малый процент памяти, поэтмоу использование external storage может дать преимущество
* во многих ситуациях. Но, самый главный минус - к файлам приложения, хранящегося на external storage имеют доступ все приложения
* Для external storage ужен пермишн. Эти пермишны являются dangerous. Методы для работы с этим хранилищем аналогичны, только добавляется
* слово External.
* LRUCache - least recently used - туда кладутся данные по каким-то ключам. При инициализации кэша, он ограничивается каким-то
* конечным размером. При достижении предела, редко используемые ресурсы будут из этого кэша удалены. Кэш выделяется в ОЗУ
* Итог по принципу работы памятив android: допустим, есть у нас RecyclerView, содержащий, скажем, крупнорамерные картинки. Эти картинки
* подгружаются из сети. При подгружении, эти картинки кладутся в LRUCache. И навходятся там до тех пор, пока размер LRUCache не
* превысит заданный предел. после превышения предела, картинки из LRUCache удаляются и переносятся, например, в кэш-директорию
* или удаляются совсем, ту на выбор. Очень круто ,удобно и эффективно
* SharedPreferences: уже знаем все про него. Создается в internal storage. Метод apply() асинхронный.
* LRUCache - специальный класс
* Кнопка "Очистить данные" очищает все файлы из internal storage, "Очистить кэш" только из кэш-директории
* SQLite: что это такое мы знаем. БД хранится в одном файле. Писать на него надо из одного потока. Работа с ним через Room, но
* изучим основы:
* SQL injection - внедрение внутрь sql-запроса сторонних данных.
* Метод query - возвращает курсор. Нужен для вычета из БД. Аргументы, которые идут к нему на вход дублируют обычные SQL-запросы.
* Метод insert - INSERT из SQL Для работы с БД отедльный поток
* ********************************************************************************************************************************
* Content Provider - один из 4-х основных компонентов. Встречается редко в работе. Механизм обмена данными между приложениями!
* Приложения - отдельные процессы, изолированы друг от друга. Наиболее частый случай использования - импорт контактов из приложения
* контактов. Объявляется в манифесте. Предоставляет подобие REST-интерфейса в виде URI:
* Схема URI для контент-провайдера объявляется в виде content://
* Формат запроса данных похож на SQL-запросы. Есть несколько встроенных провайдеров: контакты, лог звонков, галерея, она же
* MediaStore. Использование: запрос разрешения в манифесте. Формируем URI для доступа к контенту и получить данные в виде курсора
* Вставка данных через insert. User Dictionary - позьзовательский словарь, в котором сохраняются слова пользователя и помечаются наиболее
* часто употребляемые слова. Для чтения этого словаря нужен пермишн READ_USER_DICTIONARY.
* Формирование URI: 1) authority 2)table
* Package Manager проверяет совместимость authority с предоставленным доступом.
* Пример: content://user_dictionary/words/23 | URI контент-провайдера пользовательского словаря, получающий доступ к слову с индексом 23
* Для запроса данных используются курсор, ему передается URI.
* ContentResolver - ужно чтобы в одном приложении был интсрумент отбирал данные, а второй принимал через Binder через сериализацию
* ContentResolver - это клиент контент-провайдера в другом приложении.
* Нужно помнить про SQL Injection и делать подстановки. Не стоит доверять пользовательским запросам. Нужно валидировать
* введенные им данные.
* Обновление данных методов update, удаление delete()
* Нужен ли нам контент-провайдер?: 1)Собираемся ли мы отдавать много сложных данных в другое приложение?
* 2)Сообираемся ли мы отдавать данные по запросу из другого приложения?
* Если нет, то, нет, не нужен!
* Для уникальности URI используется package name приложения.
* URIMatcher - интрумент для разбора URI и понять, солответсвует ли он какому то другому URI
* Объяляется в манифесте атрибутом <provider>. Отсновной атрибут authorities - идентификатор контект-провайдера.
* Для реализации контент-провайдера нужно наследоваться от ContentProvider. ContentProvider - первый объект, создающийся
* при запсуке приложения. Основной обязательный метод onCreate(). Метод getType() возвращает MIME-type.
* MIME-TYPE: начинается с vnd. По этому запросу мы поймем, какие данные нам придут.
* Константы для контент-провайддера лучше написать в специальном контрактном классе.
*
*
*
* */
public class AndroidDataWork {
}
