package ru.pschsch.pschschapps.studyingapp;
/*Окей, let's go! Начали обучение Android-разработке. Здесь будет вся информация по данной теме.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Структура Android ОС:
* Структуру Android ОС составляют следующие элементы в порядке инициализации:
* 1)Ядро Linux - инициализация kernel операционной системы
* 2)Hardware Abstraction Layer - обеспечивает доступ к системным и аппаратным ресурсам устройства.
* 3)Native Libs - нативные C/C++ библиотеки , необходимые для работы ОС
* 4)Android Framework(он же Android SDK) - написан на Java, необходим для работы с приложениями.
* 5)Applications - собственно, сами приложения.
* Т.е, по сути, 5 уровней ОС. Разработчикам без каких-либо специальных манипуляций доступен
* только внешний уровень работы с ОС. При разработке приложения с root-правами, необходимо
* работать на более глубоких уровнях с ОС.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Этапы запуска Android OC:
* 1)Инициализация CPU
* 2)Bootloader - инициализация RAM и загрузка Linux Kernel
* 3)Kernel - инициализация среды языка С, драйверов, подсистем ядра
* 4)init - операции с ядром, загрузка native библиотек
* 5)Native daemons - библиотеки для работы с устройствами
* 6)ART - Android RunTime - Android-вариант JVM. После инициализации работает только Java-код.
* 7)Zygote - главный процесс ART. Все процессы наследуются от Zygote. Это те процессы, с которыми
* взаимодействуют пользователи и разрабортчики прикладного ПО. Система безопасности Android
* устроена так, что на каждый процесс взаимодействия с ОС создается отдельный пользователь процесоом
* Zygote, т.е другой пользователь не может получить доступ к процессу во время его выполнения.
* Запуск приложения: 1)Инициализация через Zygote UnixDomainManager. Далее инициализация метода fork().
* Метод fork() - это метод загрузки приложения. С помощью данного метода происходит инициализация:
* 1)System Service - фреймворк, позволяющий регистрировать системные процессы и осуществлять
* управление доступом. Также, через fork() - ActivityManager. Через него реализация потока
* класса Binder. Класс Binder наследует Object и имплементирует интерфейс IBinder. Нужен для
* реализации потока Activity. Через поток Activity реализуются уже сами Activity.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Устройство приложения: формат байт-кода Java отличается от ART: source code .java компилируется
* в байт-код .class и other.class .Далее ART создает на базе байт-кода classes.dex,
* AndroidManifest.xml и директорию Resources. Собирается все это в .zip-архив Android с
* расширением .apk, с которым при запуске работает ART.
*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* AndroidManifest.xml - без данного файла невозможно функционирование приложения - в нем
* прописывается конфигурация приложения, здесь прописываются: package name, разрешения, особенности
* запуска, точки входа в приложение. В отличие от Java-приложений, где в качестве точки входа
* используется метод main(), в Android он скрыт, его ф-ии могут выполнять: Activity, Service,
* Receiver и ContentProvider. В манифесте описываются точки входа.
*   * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Основные компоненты Android-приложения: 1) Activity - точка входа в приложение и визуальная
* часть. 2) Service - выполнение фоновой активности. 3)Receiver - оповещения, методы реагирования,
* на изменяющиеся условия работы приложения. 4)ContentProvider - поставщик данных. Производит
* обмен данными между процессами. 5) Application - базовый класс приложения.
*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Структура AndroidManifest.xml
* 1)Permissions - запрашиваемые разрешения у пользователя
* 2)<manifest> - в нем прописывается package name приложения (он же идентификатор приложения)
* android:VersionCode - версия приложения, вносится значение типа int. Когда нам предлагается
* обновить приложение, это значит, что разработчик выложил в Google Play приложение со следующим
* значением VersionCode. Значение всегда возрастает, на единицу с каждой новой версией
* android:VersionName - читаемое представление версии, удобно для разработчика. Вносится
* строковое значение. Например, 0.0.0.1alpha.
* android:installLocation - директория установки. Например, auto.
* 3)<application>
* 4)<activity> ActivityManager ищет прописанную в манифесте Activity по имени класса этой Activity.
* При прописывании Activity в Manifest перед именем класса Activity ставится точка. Это гворит
* о том, что наша Activity относится к тому package name, который прописан в manifest.
* Если нажать на имя Activity в манифесте с зажатым CTRL, то откроется класс этой Activity.
* 5).gitignore - система контроля версий, генерирует исключения для файлов, которые не должны
* быть в том или ином репозитории.
* 6)build.gradle - файл сборщика Gradle. Всего 2 файла - один на модуль приложения, второй
* на весь проект в целом.
* Запуск приложения проводится системой, т.е пользователь получает callback от системы.
* Пользователь при работе с Android взаимодействует с callback-системой.
* Все ресурсы в Android-приложениях обладают ID - т.е если нам необходимо сослаться на какой-то
* ресурс, мы должны просто сослаться на ID этого ресурса.
* Android Device Bridge(ADB) имеет 4 функции: adb logcat - вывод лога работы приложения
* adb shell - запуск консоли системы
* adb push - загрузка файла в устройство
* adb pull - выгрузка файла из устройства
*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Основные компоненты Android с описанием:
* Activity - это окно приложения. Обычная пустая Activity - это белый фон. При создании
* Activity, система делает это за нас. Activity обязательно прописывается в AndroidManifest,
* из которого берутся параметры реализации Activity. Без объявления Activity, приложение
* падает, бросая RunTimeException. Жизненный цикл Activity и состояния осуществляются через
* стандартные методы. Эти методы вызываются ОС, девелоперы только выполняют в них действия.
* Activity - абстрактный класс Activity. От него наследуются все Activity. В нашем случае,
* MainActivity наследуется от AppCompatActivity - это библиотека поддержки старых устройств.
* Названия методов, выполняющих те же функции, что и в классе Activity отличаются. В самых старых
* проектах Android использовались классы FragmentActivity, затем ActionBarActivity.
* Последовательность: 1) onCreate - система создает Activity с помощью данного метода. Здесь
* прописывается разметка Activity(layouts). После выполнения метода onCreate(), активность
* принимает статус Created.
* 2)onStart() - метод запускает Activity  и выводит на экран. После этого она принимает статус
* Started. Также она становится visible - т.е видима на экране
* 3)onResume() - данный метод выполняет полную инициализацию Activity, приготавливает ее
* к работе, дает конечный статус Resumed.
* 4)onPause() - данный метод вызывается при частичном перекрывании Activity, например в случае
* вывода верхней шторки. Данный метод приостанавливает работу Activity,т.е вводит статус
* Paused. Также Activity становится partially visible.
* 5)onStop() - вызывается при полном перекрывании Activity(hidden). Например, при сыкрытии
* в фон. Переходит в состояние Stopped.
* 6)onDestroy() - может быть вызван для Activity в статусе Stopped. Полностью неконтролируемый
* со стороны разработчика процесс, может быть вызван, например, в связи с нехваткой ОЗУ.
* Из всех этих методов параметры передаются только методу onCreate. Он является подобием
* конструктора Activity - как конструктор объектов в Java.
* Сохранение состояния Activity и уничтожение Activity: как уже известно, onDestroy()
* вызывается непредсказуемо, поэтому есть способоы завершения Activity:
* 1)метод finish() - данный метод принудительно вызывает onDestroy(). Нет гарантии, что onDestroy
* вызовется сразу, это может произойти с задержкой.
* 2)Поворот экрана - в этот момент уничтожается Activity и создается новая. То есть, если
* у нас Activity под portrait формат, то при смене ориентации нужна переразмеченаая Activity
* под landscape формат. Вместе с Activity уничтожаются и обработанные ею данные - это самая
* крупная боль разработчика, так как Activity уничтожаются, а данные должны быть всегда актуальны.
* Т.е, нельзя хранить какие-либо полезные данные внутри Activity ввиду непредсказуемого
* жизненного цикла!!!!!
* Но, базовые механизмы для сохранения Activity все же предусмотрены:
* 1)onSaveInstanceState(Bundle state) - метод сохраняет состояние экземпляра Activity в эк-
* земпляре коллекции Bundle
* Bundle - это коллекция, доступ к элементам которой осуществляется по парам ключ-значение.
* Ключ - это строковая константа, которая по своему значению возвращает значение из коллекции
* Bundle, которое соответсвует значению из коллекции. Т.е, при уничтожении Activity, ее данные
* помещаются в объект этой коллекции. При создании новой Activity, возвращены с помощью
* метода onRestoreInstanceState(state), который возвращает данные из объекта типа Bundle.
* Это рекомендуемый от Google способ.
* Но, ввиду асинхронности действий, может произойти следующее: метод onSaveInstanceState()
* может вызваться, а метод onDestroy() - нет. Это приведет к тому, что onRestoreInstanceState()
* не вызовется, так как для его вызова необходим вызов onDestroy(). Данные в экземпляре
* Bundle хранятся недолго, и на их хранение выделяется небольшой объем памяти(порядка 1 МБ).
* То есть, эти данные могут быть переданы только с уничтоженной Activity на заново созданную в
* очень короткий промежуток времени. Иными словами, буфер для быстрой смены Activity, храня-
* щий в себе очень небольшой объем данных.
* Обычные консольные приложения имеют одну точку входа, одну точку выхода, которые при запуске
* выполнили прописанные команды и завершились. В нашем случае, мы работаем с графическими приложениями,
* которые работают до тех пор, пока они не получат команду завершиться. Как это работает:
* В случае Android-приложения также присутствует метод main(), это мы уже знаем, но он скрыт.
* И в нем прописан бесконечный цикл. Внутри это цикла присутствует обработчик очереди сообщений
* ОС, для того, чтобы сообщить программе, о том, что пользователь совершил какое-то действие
* в приложении, кидает сообщение об этом в обработчик. Они набираются, и, по мере необходимости,
* вычитываются оттуда по принципу очереди. Это все выполняется в основном потоке. В случае
* графических приложений, он называется не main поток, а UI поток. В Android также присутствуют
* классы Handler, Looper и HandlerThread(об этом позже)
* Т.е методы onCreate(), onStart() и т.д. вызываются из очереди сообщений. И так как они
* выполняются в одном потоке, то выполняются последовательно.
* Нужно учесть, что последовательность вызовов методов может расходиться при работе с
* несколькими Activity. Например, допустим, после метода onStop() первой Activity должен
* выполняться onStart() метод второй Activity, не факт что так и произойдет.
* Ни в коем случае нельзя выполнять какие-то долгие операции в основных методах Activity.
* Например, загрузка какого-то большого объема данных, или чтения с файла большого объема данных
* Так как, когда начинает выполняться эта операция, обработка очереди сообщений прекращается.
* Это значит, приложение зависает. В это случае, пользователю будет предлагаться прибить
* приложение, завевршить его аварийно. Это относится ко всем действиям внутри UI потока.
* Все длительные операции выполняются в фоновом потоке(позже)
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Task и Back Stack:
* Task - набор нескольких Activity, вызывающихся последовательно. У Task есть Back Stack -
* стек, в котором хранятся Activity, относящиеся к Task. Одна Activity может хранить несколько
* экземпляров в стеке(например, из Activity1 сздали Activity2, Activity3 и т.д)
* Пример:
* |----------------------------------------------------------------------------------------|
* |Activity1    Activity2    Activity3    (нажали конпку назад)    Activity2               |
* |             Activity1    Activity2    (Activity3 уничтожилась) Activity1               |
* |                          Activity1                                                     |
* |----------------------------------------------------------------------------------------|
* Все выше - один Back Stack
* У каждого приложения Task свой. При создании Activity стек автоматически создается. Но можно
* принудительно при создании Activity создать новый Task. Без такого действия, новые созданные
* Activity просто определяются в базовый Task. При записи новой Activity в Back Stack, у
* старой Activity вызывается метод onStop(), а при уничтожении вверхней в стеке Activity
* у предыдущей вызывается onResume().
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Intents(Способы открытия Activity);
* Intent - это специальный служебный объект в Android SDK. Представляет из себя некое
* сообщение, которое мы отправляем. Их существует 2 типа: explicit intent и implicit intent.
* Когда мы внутри приложения, например, вызываем свою последовательность Activity, мы использу-
* ем Explicit Intent(явное обращение). Использование intent:
* Intent intent = new Intent(this, SomeActivity.class);
* Context - абстрактный класс, от которого наследуется класс Activity. При объявлении объекта
* класса Intent, ему передается объект класса Context с помощью метода getContext(), который
* возвращает объект контекста, к которому применен(в случае Activity - возвращает объект
* Activity). Можно использовать ссылку this, она ссылается на объект класса Context в конструк-
* торе Intent, т.к мы работаем в Activity, то и сошлется на Activity. SomeActivity.class - это
* та Activity, которую мы хотим вызвать из нашей Activity.
* startActivity(intent) - вызывается та Activity, которая прописана в объекте intent. Помним,
* вызовется не сию секунду.
* Implicit Intent - необходим, когда нам нужно вызвать активность другого приложения.
* (неявное обращение). Данный интент нужен, когда мы не знаем класс той Activity, которую
* нужно вызвать. То есть нужно использовать приемы, по которым будет понятно, что мы хотим
* примерно показать, открыть в нашем приложении. Один из таких приемов - ACTION. Это просто
* строка. В AndroidManifest прописывается обязательно, что приложения могут реагировать
* на ACTION. Объявляется это в категории <intent-filter>. Там прописывается, на какие события
* может реагировать наше приложение. Например, прописанное в intent-filter событие:
* <action android:name="android.intent.action.CALL" /> - означает, что при вызове этого ACTION
* устройство вызовет приложение для звонков. ACTION.MAIN - это означает, что Activity
* является базовой, с нее начинает отображаться приложение. "android.intent.category.LAUNCHER"
* говорит о том, что Activity запускается с лончера.
* Пример создания implicit intent'a:
* Intent intent = new Intent(Intent.ACTION_VIEW);
* intent.setData(Url.parse("https://vk.com/id122773318"))
* startActivity(intent);  //данный метод покажет страницу, указанную в intent, в данном случае
* Итог: основные свойства интентов:
* Explicit intent: адресуются конкретному компоненту(с помощью component name)
* Обычно используются для запуска внутренних компонентов
* Implicit intent: не имеют конкретного адресата, обычно используются для запуска компонентов
* сторонних приложений, система сама находит наиболее подходящие компоненты. Если компонент
* можно открыть несколькими способами, автоматом появляется всплывающее окно, предлагающее
* чем мы хотим открыть компонент.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Получение результата от Activity:
* Обычно возникает ситуация, когда нам не только нужно открыть Activity, но и получить какие-то
* данные с нее. В настольных ОС это называется модальным окном - окно открывается поверх
* действующего, выполняются какие-то действия и происходит возврат обратно в рабочее окно.
* В Android это реализовано следующим образом: можно из одной Activity "попросить" другую, чтобы
* она произвела какие-то действия. То есть, есть Activity - получатель, и есть Activity -
* отправитель. Реализация:
*
* Запускаем Activity-получатель:
*
* Intent intent = new Intent(this, WordsWriter.class)
* startActivityForResult(intent, какая_то_константа) // здесь уже применяется модернизированный
* метод, который не просто запускает Activity, а еще ждет результат от нее.
* @Override
* void onActivityResult(int code, int result, Intent data){
* if(code==какая_то_константа && result == RESULT_OK){
* if(data.hasExtra("result"){ блок_кода   // проверяется, имеет ли data result
*         }
*     }
* }
* Activity-отправитель
* Intent data = new Intent(); // новый интент data
* data.putExtra("result","какая-то еще ненужная строка");  // помещаются в data эти строки
* setResult(RESULT_OK, data);  //setResult - задает RESULT_OK в объект data.
*
* В метод onActivityResult вернется результат второй Активити. Условие в первой activity
* добавляется, чтобы отследить, с какой activity пришли данные, например какая_то_константа
* это ключевое слово для получения данных со второй activity. Также проверяется сам result.
*
*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Фрагменты:
* Фрагменты - это компоненты Activity. Представляют собой части пользовательского интерфейса
* в Activity. Google настоятельно рекомендует сейчас осуществлять навигацию в приложении через
* Bottom Navigation Bar. Фрагмент - это некоторая область на экране, контейнер, в котором
* находятся наши элементы графического интерфейса. Их можно показывать как
* один, так и несколько в одной Activity. То есть, при переключении по бару навигации, происходит
* переключение между фрагментами. Пошли еще с android 3.0 для планшетов.
*
* Жизненный Цикл Фрагмента: 1)onAttach() - пристыкование к Activity
* 2)onCreate() - аналог onCreate() у Activity, пока нет доступа к элементам UI
* 3)onCreateView() - создается View фрагмента, который надо отдать системе.
* 4)onActivityCreate() - фрагмент создан, есть доступ к UI
* 5)onDetach() - фрагмент открепился от Activity.
* Жизненный цикл фрагментов связан с жизненным циклом Activity и выполняется параллельно.
* Объявление фрагментов: есть 2 способа:
* 1)В ресурсы layout добавить атрибут <fragment>. Поля атрибута схожи с полями атрибута
* <activity>
* 2)Из кода: создать класс, унаследованный от Fragment, обращаемся к FragmentManager, который
* есть у Activity через метод getFragmentManager() и beginTransaction() - этот метод говорит
* о том, что мы хотим сделать послдеовательность действий с фрагментами.
* transaction.replace() - заменяет выделенное место на фрагмент
* transaction.addToBackStack(null) - при нажатии Назад, фрагмент убирается(добавляет в Back Stack)
* transaction.commit() - выполнить транзакцию
* FragmentManager:
* Позволяет управлять фрагментами, добавлять, работать со стеком этих транзакций, нужно
* вызвать commit для выполнения транзакции. Вся работа идет через FragmentTransaction.
* Фрагменты из Support Library несовместимы с фрагментами из стандартного API!!!!!!!!!!!!
* У фрагментов всегда конструктор должен быть пустой!!!! При смене Activity уничтожаются
* также и фрагменты, соответственно, те данные, которые переданы в конструктор, не смогут
* быть проинициализированы при смене фрагментов. У фрагментов есть метод
* setArguments(Bundle state). Рекомендуется использовать его. Начиная с Android 5.0,
* класс Application наслдеуется от MultiDexApplication - обход ограничения 65к методов.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Простые UI элементы:
* 1)Основной класс визуальных компонентов - класс View. Все остальные компоненты являются
* наследниками этого класса. Иерархия UI элементов очень глубокая. Самый простой виджет - это
* TextView - отображение текста. ImageView - элемент, отображающий картинку.
* ImageButton - картинка с кнопкой. Spinner - выпадающий список
* WebView - позволяет отображать браузер в приложении. Пикеры времени и даты, зум кнопки,
* медиа контроллеры, флипперы и прочее. Часто, при долгих операциях, вставляется анимация, кото-
* рая используется для "отвлечения " пользователя. Так пользователю кажется, что загрузка
* происходит гораздо быстрее , развлекает его)).
* GUI Layouts: это азовые ViewGroup, предназначенные для размещения View в них.
* Основные из них: FrameLayout, LinearLayout, RelativeLayout, TableLayout.
* LinearLayout отображает элементы линейно, FrameLayout - куча элементов в окне.
* AbsoluteLayout устарел(deprecated).
* FrameLayout - layout, не поддерживающий никакого порядка расположения элементов. Позволяет
* накладывать View друг на друга
* RelativeLayout - тип верстки, при котором позиционирование элементво происходит друг
* относительно друга и оносительно главного контейнера. Данная разметка позволяет
* делать следующее:
* 1)Атрибуты позиционирования относительно контейнера
* 2)Атрибуты позиционирования относительно других элементов
* 3)Выравнивание относительно других элементов
* LinearLayout - область верстки делится на строки, в каждую строку помещается один элемент
* Разбиение м/б как горизонтальное, так и вертикальное. Указывается в атрибуте
* android:orientation. Является самым быстрым в работе, так как для измерения свободного пространства
* и отрисовки элементов нужно произвести операцию всего один раз. Является наиболее предпочтительным
* если отвечает нужным требованиям. Для Relative ,например ,нужен двойной обход.
* Атрибут android:gravity
* URI - Uniform Resources Identifier - индентификатор ресурсов в implicit intents.
* по которому можно определить абстрактный ресурс или физический.
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* Пример вывода элементов из Bundle:
    static final String SOME_KEY = "key1"   //ключи
    static final String SOME_KEY2 = "key2"
    @Override
    public void onSaveInstanceState(Bundle savedInstanceState){  //метод сохранения в Bundle
    savedInstanceState.putInt(SOME_KEY, mCurrentVal);  //поместить значения с соотв.ключами
    savedInstanceState.putInt(SOME_KEY2, mCurrentVal2);
    super.onSaveInstanceState(savedInstanceState);  //вызов метода суперкласса, сохраняются
    //данные с иерархии Вьюшек(View). Activity сохраняет иерархию View в этот объект
    }

    @Override
    public void onRestoreInstanceState(Bundle savedInstanceState){
    super.onRestoreInstanceState(savedInstanceState); //Выводятся данные с иерархии View
    savedInstanceState.getInt(mCurrentVal);
    savedInstanceState.getInt(mCurrentVal2);
    }
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*/
public final class AndroidStudyingClass {
    public static void main(String args[]){
        System.out.println("И че, будет работать?"); //работает))
    }
}
