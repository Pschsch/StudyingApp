package ru.pschsch.pschschapps.studyingapp;

import android.support.v7.app.AppCompatActivity;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.SnapHelper;

/***************************Инфа с технострима по Adapter Views и сервисах*********************************************************/
/*Контейнеры и сервисы
* Adapter Views - это контейнеры - это вьюшки, которые на самом деле первоначально пустые, но внутри себя могут содержать элементы
* Это родительские вью, которые являются не просто родителями для своих дочерних вью, но дочерние вью каким-то образом упорядочены
* внутри них. Простейшие - GridView, ListView, Spinner.
* ListView - список элементов. Элементы являются ячейками. В Adapter Views отображаются на самом деле элементы, но не сами вью.
* Для работы таких вью нужны адаптеры. Адаптер - это своего рода переходник между приложением и Adapter View. Адаптеры решают
* простую задачу: разработчики Android не знают, сколько данных для хранения может потребоваться разработчику приложения, поэтому
* они ввели адаптеры, которые являются проводником данных от элементов к непосредственно UI. Контейнеры, использующие адаптеры,
* требуют для своего заполнения специальный класс адаптера, который ответственен за предоставление данных контейнеру и позволяет
* узнать, какой объем данных необходимо вывести. Каждый адаптер содержит несколько базовых методов: getView, getCount, getItem,
* getItemId. Метод getCount() очень важен по следующим причинам: нашему вью очень важно знать, сколько на самом деле элементов
* мы можем отобразить. Если , у нас список, содержащий какое-то действительно большое количесвто данных, пусть 1000 элементов,
* в методе getCount() мы укажем, что у нас 1000 элементов. Но Java Heap не выделится по такое огромное количесвто объектов, они могут
* с легкостью занять всю ОЗУ. Поэтмоу, был придуман следующий механизм: вью загружает не все элементы, а только часть, которая
* может уместиться на экране, пусть 10 элементов + небольшой запас для прокрутки на еще один экран примерно. Тем самым, ОЗУ не
* будет забита всем списком, а только его рабочей частью, но вью знает, что есть еще элементы и вслучае надобности быстро их
* загрузит. Для того, чтобы отобразить каждый из этих элементов, используется метод getView. Большинство адаптеров наследуются
* от абстракного класса BaseAdapter. getItemId позволяет определить тип вьюшки.
* Как работает эта схема: элементы списка делятся на 2 условных типа: Visible View и Scrap View. Scrap View - это вьюшка
* которая ушла за границы экрана, но еще окончательно не была стерта из памяти. При прокрутке, адаптер вью смотрит, может ли
* он отобразить вьюшку, которая входит в этот пресловутый тип, если может, то он ее не создает заново, а переиспользует, таким
* образом эконовив значительное количесвто вычислительных ресурсов. В резлуьтате получается, что из этих 1000 элементов в
* результате задействуются только 10 из них. GridView и ListView условно deprecated, сейчас используется RecyclerView.
* Адаптер сам по себе не должен хранить данные, он должен быть только мостом между ресурсами и самим приложением !!!
* Этот паттерн называется медиатор! Самый простой готвый адаптер - ArrayAdapter - он служит только для самых простых адаптеров.
* Это адаптер берет данные из массива и требует чтобы все элементы были одинаковы. ArrayAdapter практически никогда не используется
* в современных приложением, ввиду своей негибкости. Более распространен BaseAdapter - от него наследуются при разработке собственного
* адаптера.
* ViewHolder Pattern - этот паттерн и реализует вот те самые Scrap View. С помощью ViewHolder мы проверяем, если вьюшка с заданной
* позицией, которую нам надо отобразить не null, то мы просто возвращем эту вью и работаем с ней, если же этой вью в памяти нет
* и вью с заданной позицией - null, то мы инфлейтим эту вьюшку из сооветствующего ресурсам и присваиваем ей тег, по которому, пока
* вью будет в памяти, мы сможем получить к ней быстрый доступ. ViewHolder ужен еще и потому, что частое использование метода
* findViewById крайне негативно сказывается на производительности, и поэтмоу, если не использовать ViewHolder, списо наш условный
* может сильно дергаться при прокруткею так как все работы с View происходят в UI потоке. К каждой созданной вью применяется
* тег, вместо повторного вызова метода findViewById и вью получается уже по тегу.
* RecyclerView - самый современный список. Гибрид всех видов старых списков + современные подходы. Сам по себе RecyclerView
* не имеет какого-то конкретного типа отображения элементов. За это у него отвечает LayoutManager. LayoutManager напрямую
* связан с адаптером, который уже в свою очередь связан с ресурсами элементов RecyclerView. RecyclerView позволяет формировать
* действительно сложные элементы. ViewHolder встроен изначально в RecyclerView.
* LayoutManager: простейший менеджер - LinearLayoutManager - позволяет по сути, отобразить RecyclerView в виде ListView.
* У LinearLayoutmanager есть 3 формы работы: VERTICAL , HORIZONTAL и INVALID_OFFSET. У RecyclerView есть вспомогательный класс
* SnapHelper - это абстрактный класс, от которого наследуется класс для установки совйств снэпа нашего RecyclerView.
* SnapHelper приклепляет элемент списка к границам экрана.
* Используется для замены тяжелого и глючного ViewPager. Внутри ViewPager хранятся фрагменты.
* GridLayoutManager - менеджер установление сетки. Помимо ориентации, устанавливаются количество столцов. Можно реализовать
* свой LayoutManager , наследующийся от LayoutManager.
* Создание адаптера для RecyclerView:
* public class SomeRVAdapter extends RecyclerView.Adapter<SomeViewHolder>{}
* Адаптер RecyclerView наследуется от вложенного класса Adapter параметризованного типа, в качестве типа на вход идет класс
* ViewHolder-а. 3 обязаельных метода для переопределния: onCreateViewHolder() onBindViewHolder() getItemCount()
* Метод onCreateViewHolder возвращает объект нашего ViewHolder-а для заданного типа View, а метод onBindViewHolder присваивает
* ViewHolder ьюшке на конкретной позиции.
* Пример класса ViewHolder-а: ViewHolder наследуется от вложенного класса RecyclerView.ViewHolder
* //В этом классе указываются ссылки на отображаемыев элементе View, например Textview:
* TextView tv1;
* TextView tv2;
* //Например, сеттим для них текст
* tv1.setText(R.string.text);
* tv2.setText(R.string.text2);
* //Далее, эти вбю заносятся в конструктор вьюхолдера:
* public SomeViewHolder(View item){
* super(item) //вызывается конструктор суперкласса для того, чтобы вью были созданы
* tv1.findViewById(R.id.someId)
* tv2.findViewById(R.id.someId2)
* }
* Методов обновления содержимого RecyclerView очень большое количество: например для обновления одного элемента есть отдельный метод
* Методы увеличения числа элементов в памяти, на эти действия можно вешать анимации. В RecyclerView нужно на каждый элемент вешать
* свой клик-листенер. setHasFixedSize() - позволяет установить конечный размер самого RecyclerView, что позволит увеличить его
* быстродействие.
* В Android есть специальная папка с ресурсами, изображающие различные анимации, напрример, при нажатии кнопки, выпадении списка и т.д.
* Эти анимации можно привязать к собственным вьюшкам, доступ к этим ресурсам можно получить через путь ?android.
* ********************************************************************************************************************************
* Сервис: специальный компонент, не предполагающий собственного пользовательского интерфейса. Сервис работает в UI потоке.
* поэтмоу важно для него всегда выделять отдельный фоновый поток. Сервис ,также как и аткивность,прописывается в манифесте.
* Жизненный цикл сервсиа в любом случае, производится в UI потоке. В манифесте указывается с помощью тега <service>
* Единтсвенный обязательный атрибут это name - это имя класса, который реализует сервис. Сервис, как и активити, может быть запущен
* через Intent. Не стоит использовать для сервиса интент-фильтры, так как может произойти нежелательный запуск сервиса.
* Для этого существует атрибут android:exported, который за это отвечает, если false, то сервис не может быть запущен из других
* приложений. Атрибут process позволяет выделить для сервиса отдельный процесс, что даст больше ресурсов для выполнения процесса
* и сервис не будет делить память совместно с приложением. Это также позволит продолжать сервису работать, если приложение
* крашнется.
* Есть 2 типа сервисов: запущенные и связанные. Запущенный сервис при завершении своей работы не возвращзает никаких данных,
* связанный в свою очередь, по завершении возвращает какой-то callback. Сервис должен решать какую-то узкую задачу, не нужно
* его слишком раздувать.
* Жизенный цикл сервисов: оба типа сервисов создаются методом onCreate() и завершаются методом onDestroy(). В методе
* onDestroy() как правило закрываются все подключения и потоки, чтобы можно было освободить все ресурсы после окончания работы
* сервиса. В активную фазу запущенный сервис переходит с помощью метода onStartCommand(), связанный - с помощью метода
* onBind(). Когда клиент отвязывается от связанного сервиса, вызывыается метод onUnbind().
* Метод onStartCommand:
* @Override public int onStartCommand(Intent intent, int flags, int startId)
* Данный метод возвращает интовое значение. Таких значения 3:
* START_STICKY, START_NOT_STICKY, START_REDELIVER_INTENT
* Как только сервис запускается, его приоритет постепенно понижается как процесса. Соответсвенно, ОС, может его по каким-то
* причинам остановить. Вот эти интовые константы как раз и определяют стратегию перезапуска сервиса:
* Если установить константу START_STICKY, то при остановке, сервис будет перезапушен, если START_NOT_STICKY - то не будет,
* если START_REDELIVER_INTENT - то сервис перезапускается и получает параметры от intent, посредством которого он был запущен
* void startForeground(int id, Notification notif) - позволяет повысить приоритет сервиса.
* Класс Notifcation - класс, реализующий push-уведомления, которые показываются при фоновой работе сервиса.
* В этом режиме, у сервиса наивысший приоритет и сервис, скорее всего, не будет остановлен ОС. Начиная с 8.0, работа с сервисами
* ужесточилась, если мы не оповещаем пользователя или пользователь вышел из UI потока нашего приложения, сервис будет остановлен.
* Для создания сервиса нужно наследоваться от класса Service. Как и Activity, Service тоже просто получает callback-и от системы
* на его создание и реализацию. Принцип создания схож с Activity: Пример сервиса в классе MyService.java
* IntentService - особый сервис - упрощенный механизм работы сервиса в фоновом потоке. IntentService - подкласс сервиса, пример
* в классе . Обязательный метод, вместо onStartCommand() - onHandleIntent(). Intent-ы становятся в очередь и обрабатываюстя
* в одном фоновом потоке.
* Bound сервисы: все компоненты Android реализуются через Binder, в том числе и сами приложения - это инструмент межпроцессного
* взаимодействия в Android. Binder - это низкоуровневый инструмент, написанный в нативном коде, и для упрлщения работы с ним
* существует AIDL - Android Interface Definition Language - с помощью этого языка мы можем описать сущности, которые хотим
* передать Binder-у. У AIDL свои файлы с расширением .aidl . Импортировать нужно даже те aidl-файлы, которые находятся в том
* же пакете. Ключевое слово oneway в декларации void метода, означает, что метод будет вызван асинхронно. Использовать можно только
* примитивы, String, List и Parcelable, объявленные в других aidl-файлах. С AIDL-интерфейсами работают Bound-services
* С помощью AIDL-интерфейсов реализуется код класса Stub, который сериализует-десериализует данные в бинарный код ля передачи
* между компонентами. Сам Binder определяет несколько низкоуровневых методов, в исходнике можно посмотреть.
* При вызове bound service из интента, используется bindService(Intent i, ServiceConnection sc, int bind_auto).
* ServiceConnection - это интерфейс, который содержит 2 метода: onServiceConnected и onServiceDisconnected. 1-й вызовется, когда
* Binder свяжется с сервисом, 2-й, когда отвяжется от него. При использовании биллинга, как раз используются bound-сервисы,
* кладется специальный aidl-файл , открывается сервис, идет привязка к нему и вызываются определненные методы.
* Для начала работы сервиса через интент, вызывается метод startService(intent).
* *******************************************************************************************************************************
* Планировщик задач: нужен когда не нужно выполнять задачи немедленно. Поддерживает периодическое выполнение. Поддерживает
* условное выполнение - при соблюдении каких-то условий, какие-то команды выполнятся.
* 1)TimerTask - простейший планировщик
* 2)ScheduledExecutor - пул потоков из java.util.concurrent
* 3)Handler.PostDelayed - выполнение действия по прошествии определенного промежутка времени.
* Для 2 и 3 необходим живой UI приложения.
* 4)AlarmManager - компонент фреймворка, не рекомендуется
* 5)SyncAdapter - плановые синхронизации
* 6)JobScheduler - самый современный способ работы
* Google рекомендует использовать JobScheduler. JobSheduler корректно работает совместно с DozeMode, доступен выше 21 версии api.
* Включает в себя оптимизацию расхода заряда батареи, оптимизацию использования ОЗУ, прцессорного времени.
* Чтобы задачи сработали, должен выполняться ряд условий: устройство заряжается, сетевое подключение без ограничений, устройство
* не в роуминге, устройство в состоянии Idle т.е бездействия. Если мы хотим выполнить задачу прямо сейчас, она не выполнится прямо сейчас
* всегда будет delay. Job Scheduler работает только на api21+ , на ранних версиях его никак нельзя использовать, даже через
* compat! Можно использовать сторонние библиотеки, организующие работу по расписанию.
* Для того, чтобы создать джоб, нужно наследоваться от абстракного класса JobService. Он содержит 2 метода: onStartJob()
* и onStopJob() - первый вызовется при запуске джоба, второй, соответственно, при остановке. Оба метода возвращают boolean.
* Они могут выполняться здачи в фоне. JobService - это обычный сервис, и его нужно объявлять в манифесте тегом <service>
* Для него нужно специальное разрешение android:permission.BIND_JOB_SERVICE.
* У каждого джоба есть метадата - конфигурация. Для этого у джобы есть класс JobInfo с паттерном билдера.
* JobInfo.Builder builder = new JobInfo.Builder();
* builder.setBackOffCriteria(initialBackOff, policy)
* .setExtras(bundle)
* .setMinimumLatency(latency)
* .setOverrideDeadline(delay)
* .setPersisted(isPersisted)
* .setRequiredNetworkType(type)
* ////
* JobIfo info = builder.build(); // после указания всех параметров, билдится джоб-инфо.
*
* Чтобы включить JobScheduler в кэш ОС, нужно его присвоить методом getSystemService из контекста:
* JobScheduler scheduler = (JobScheduler) context.getSystemService(JOB_SCHEDULER_SERVICE);
* //context - наш текущий объект контекста, JOB_SCHEDULER_SERVICE - это некий идентификатор системы, по которому android определит
* что мы вызываем именно JobScheduler.
* scheduler.schedule(info); //scheduler выполнится в соответсвии с теми триггерами, которые были прописаны в JobInfo.
*
* 
*
* */





public class AndroidAdapterViewsServices extends AppCompatActivity {
    RecyclerView view = new RecyclerView(this);
    LinearLayoutManager manager = new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false);


}
