package ru.pschsch.pschschapps.studyingapp;

import android.widget.Button;

/*CUSTOM VIEW
/*Задание: сделать кнопку с закругленными краями.*/
/*
* Создание вью - задача очень сложная. Наиболее часто используемый способ - создание сложного элемента списка RecyclerView.
* Что у нас есть:
* Иерархия вью: Базовый класс - View. От него растут TextView, ImageView и ViewGroup. Button апример уже растет от TextView.
* Общий алгоритм создания вью:
* 1)Наследование от наиболее близкого по функционалу View, наследоваться непосредственно от View, если нет вью, которые
* из коробки смогут предоставить базу необходимых свойств.
* 2)Определение атрибутов
* 3)Применение атрибутов в классе.
* 4)Добавление нужных свойств и событий.
* 5)Реализуем весь функционал
* 6)обработка всех видов ввода
* 7)Предоставление возможностей для людей с ограниченными возможностями
* Кастомные атрибуты должны быть доступны из XML.
* Жизненный цикл View: onAnimate() onMeasure() onLayout() onDraws()
* Важные функции: 1)onFinishInflate() - callback в тот момент, когда вью экслудится из XML. Этот метод вызывается в момент
* инфлейта вьюшки в раметку, в нем во время этого действия можно что-то сделать
* 2)onMeasure() - метод будет вызван, когда вьюшка будет измеряться - самый важный метод
* 3)onLayout() - вызовется, когда у вьюшки будут обрабатывать размер и ее расположение относительно других вьюшек
* 4)onSizeChanged() - если размер вьюшки в ходе работы программы бдует именене, вызвеотся этот колбэк.
* 5)onDraw() - отрисовка вью
* 6)onTouchEvent() - когда тач по вью
* 7)onFocusChanged() - когда фокус на вью
* Атрибуты: объявляем в специальном XML, например attrs.xml. В этот файл добавляем раздел <declare-styleable> с именем нашего
* View. Внутри этого раздела и прописываютися нужные нам атрибуты
* Атрибуты бывают типов: reference, color, boolean, dimension, float, integer, string, fraction, enum, flag.
* При использовании вьюшки, указывается уже не там TextView или там EditText, а полный пэкдж-нейм с именем класса вьюшки, например:
* ru.pschsch.pschschapps.RoundCornerButton
* Загрузка атрибутов: по умолчанию есть 3 коструктора, важных 2: 1-му передается контекст, а второму еще и атрибуты. Если, допустим,
* при использовании 1-го конст труктора, мы объявим вью в XML, то приложение словит краш, так как не будет нужного контсруктора
* и LayoutInflater не сможет найти эти атрибуты. Атрибуты обычно выносятся в отдельный класс, а конструктору вьюшки передается
* экземпляр класса атрибутов. Для применения этих атрибудтов в конструкторе вью используется нативный класс TypedArray.
* Этот класс выделяет ресурсы под вью. Создание вью оборачивается в блок try, а в блоке finally проводится метод recycle() -
* если вдруг выйдет исключение, то блок finally все равно выполнит закрытие этой вьюшки, тем самым освободив важные нативныые ресурсы.
* Свойства и собтыия: методы invalidate() и requestLayout() 1-й нужен для реагирования для именения состояния вью.
* 2-й нужен, сли изменгились размеры вью.
* Метод onDraw(Canvas) Рисуем на Canvas с помощью объекта Paint.
* Отрисовка: у Canvas есть набор базовых методов: текст рисуется с помощью метода drawText, примитивные геометрические фигуры
* рисуются: drawRect, drawOval, drawArc, drawLines, drawPoints. Картинки drawBitmap.
* Размеры и альфа: onSizeChanged() - когда изменен размер вью
* onSetAlpha() - установление прозрачности.
* onMeasure() - самый важный колбэк. Этот метод будет вызван у вью, чтобы узнать, сколько места занимается вью.
* Базовый класс View содержит метод measure() - этот метод производит дефолтные какие-то вычисления, затем по окончании своего
* выполнения вызывает метод onMeasure() - и вот это колбэк мы и переопределяем. В конце выполнения метода onMeasure() выполняется
* всегда метод setMeasureDimension(). Если метод не будет вызван, приложение упадет. Метод сеттит расчитанные размеры.
* Пример:
*     protected void onMeasure(int widthMeasureSpec, heightMeasureSpec){
*     int widthMode = MeasureSpec.getMode(widthMeasureSpec)
*     int widthSize = MeasureSpec.getSize(widthMeasureSpec)
*     }
*     Атрибуты вьюшки - это размер и режим, упакованные вместе.
*     Mode - режим отображения вьюшки на экране.
*     Mode и Size - специальные костанты, устанавливающиеся классов MeasureSpec.
*     Mode - бывает 3-х типов: EXACTLY AT_MOST UNSPECIFIED
*     Exactly - соответсвует точным значениями layout_width и layout_height. Иногда используется для match_parent
*     At most - wrap_content и match_parent
*     Unspecified - иногда вызывеатся для оценки размера элемента списка. Обычно еще значит wrap_content
*     Exactly приходит когда четко указан рамер лейаута вью.
* Оптимизация: самый простой способ - не создавать свой View))) Не аллоцировать объекты в нем. в onDraw ничего не делаем, кроме как
* взять готовые значения из onMeasure.
* При смене изображения вью, не забывать метод invalidate() при смене текста, например. Если не вызвать onMeasure(), то устанавливаются
* дефолтные значения изображения, а это, как правило, весь экран, что далеко не всегда гуд!
* Экземпляр класса Paint устанавливает дефолтный вид вьюшки. Преобразование dp в px: для этого в экземпляре класса Paint вызывается
* метод getDisplayMetrics().density - это и есть преобразоватние dp в пиксели. Если использовать scaledDensity, то идет преобразование
* sp в px. Это идет просто умножение существующих единиц sp или dp на число, которое относится к определенному типу экрана,
* например, для ldpi getDisplayMetrics.density вернет значение 0,75.
* Класс Paint.FontMetrics - отвечает за размер текста
* Padding - асстояние между элементами самой вью.
* После расчета размеров, конченые размеры передаются как параметры в метод setMeasureDimension().
* Атрибуты: пердача атрибутов в XML: в классе вьюшки через TypedArray:
* Context context;
* TypedArray tr = context.obtainStyledAttributes(attrs, R.styleable.ViewName, defstyleattr: 0, defstyleres: 0);
* Взаимодействие с вью путем жестов обеспечивается классом GestureDetector. У него есть свой колбэк SimpleOnGestureListener
* Этот интерфейс содержит сразу все возможные MotionEvent-ы, которые только существуют.
* Это Singletap, DoubleTap, onDown, onFling
* Этот джестерлистенер передается методу onTouchEvent в один из базовых методов инициализации вьюшки.
* Можо делать свой джестеррекогнайзер.
* Свой лэйаут: наследоваться от класса ViewGroup. Одна из главных проблем- лэйаут не знает, сколько места ему нужно, поэтому
* место им занимаемое должно измеряться исходя из количества дочерних вью в нем. Нужно будет скачать все исходники лекции технотрека
* Метод onLayout() - в исходниках
* Анимации: красота, скрытие работы приложения, визуально более отзывчивое, выделяет приложение.
* Анимации свойств: продолжительность, управление интерполяцией, повтор и поведение повтора, наборы
* анимации, время обновления фрейма, можно анимировать не только UI.
* Есть линейные и нелинейные анимации: линейные - это когда вид вьюшки изменяется равномерно за единицу
* времени. Нелинейные, это соовтетсвтенно неравномерное изменение в единицу времени, допустим,
* вначале вьюшка изменяется быстро, затем медленно. Обеспечивается за счет интерполяторов.
* Основные классы для работы с анимацией - аниматоры: ValueAnimator, ObjectAnimator и AnimatorSet.
* ValueAnimator - меняет значения во времени. ObjectAnimator - меняет параметры объекта во времени
* AnimatorSet - набор анимаций(сумма 1-го и 2-го аниматоров)
* Evaluator - вычислитель, исходя из интерполяторов должен в нужное время вернуть нужное значение
* что менять. Основные классы: IntEvaluator, FloatEvaluator, ArgbEvaluator, TypeEvaluator
* IntEvaluator - смена целых чисел
* FloatEvaluator - смена float
* ArgbEvaluator - смена цветов
* TypeEvaluator - абстрактный класс для населдования для создания собственного вычислителя, когда,
* например, нам нужно изменять наши какие-то собственные свойства.
* Интерполяторы: определяют нелинейные виды анимации: список: LinearInterpolator - простой линейный
* AccelerateDecelerateInterpolator - сначала анимация ускоряется, потом замедляется
* и т.д. классов-интерполяторов много, лучше на примере посмотреть
* ValueAnimator и ObjectAnimator:
* Алгоритм работы: 1) Создаем экзепляр класса, задаем длительность, запускаем. Для ValueAnimator
* задаем число, для ObjectAnimator - параметр, который будет изменяться.
* AnimatorSet: состоит из нескольких анимаций. По паттерну, похожему на билдер. Заполняется с помощью методов play() и with().
* AnimatorListener: нужен для проведения каких-то действий перед началом или концом анимации.
* TypeEvaluator - работа с пользовательскими типами. Имеет один метод для переопределния evaluate().
* Собственный интерполятор: вписывается формула графика, по которому чтобы мы хотели вела себя анимация.
* Анимации View: translation, rotation, scale, pivot, alpha.
* Есть свой метод animate() - в нем изменяются параметры вью. такие как scale rotation и т.д. по паттерну билдера
* Настройка анимаций через XML: анимации свойств хранятся в ресурсах в директории res/animator
* анимации преобразований в res/anim
* Задаются анимации через теги: ValueAnimator - <animator> ObjectAnimator - <objectAnimator> - AnimatorSet - <set>
* Множества анимаций могут содержать подмножества последних. Через код проще писать , чем через XML.
* Все анимации вьюшки также имеют свои теги
* Transition API: оперирует понятием сцены - состояние лэйаута, Transition - переход между сценами. Scene root - корневой лэйаут
* в котором меняются сцены.
* sceneRoot вытаскивается как ViewGroup методом findViewById. Через TransitionManager методом beginDelayedTransition(sceneRoot)
* указывает лэйаут как сцену. Также вьюшка может быть сценой. Мы лишь указываем, какие параметры должны быть изменены у вьюшки или вьюгруппы
* а анимация будет наложена автоматически.
* Типы транзишнов: ChangeBounds - Transition, овтечающий за изменение координат View внутри лэйаута.
* Fade - анимации fade in + fade out - плавное появление и исчезновение вью
* TransitionSet - множество транзишнов, в котором определяется либо пордяок выполнения транзишнов либо одновременное выполнение
* AutoTransition - выполняется когда не указан конкретный транзишн
* Фрейм-анимации - тег <animation-list> - в нем просто перечисляются картинки, которые должны по очереди меняться.
* Для внедрения гифки в WebView нужна HTML-разметка вебвью.
*
*
*
*
*
*
*
*
* */
public class AndroidCustomViewAnimation {

}
