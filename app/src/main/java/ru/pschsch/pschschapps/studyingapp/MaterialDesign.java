package ru.pschsch.pschschapps.studyingapp;

import android.support.design.widget.CoordinatorLayout;

/**********************************************Все о материальном дизайне в Android***********************************************/
/* Material Design - концепт идеального внешнего вида приложения.
Первые шаги: ActionBarSherlock - различные кнопки на экшнбаре. Дальше: Holo - документация, как должно выглядеть приложение.
Появилась светлая тема. Финальный шаг - современный Material Design - это подобие квантовой бумаги - есть некие слои, у компонентов
должна быть реакция в виде анимации. RecyclerView лучше всего вписывается в эту концепию. Ripple-эффект  - эффект расплытия
кругов при нажатии. Быстрая отрисовка. Ощущение "живого" интерфейса. Сайт material.io ОБЯЗАТЕЛЬНО ПРОЧИТАТЬ. Гайдлайны по виду
приложений. Нужно для получения фичеринга - продвижения в магазине.
1)Библиотека design!
Алгоритм: 1) LaunchScreen - визуализация запуска приложения. Оказывается, для сплэш-скрина предусмотрен специальный интерфейс
AsyncNotesLoader.LoaderDelegate. Для этого, в методе onCreate() сплэш-скрина просто создается объект класса AsyncNotesLoader
также обязательно переопределяется метод onNotesLoaded() в котором объявляется интент для запуска основной Activity.
2)Cards - обеспечивается CardView. Используется как подложка элемента в RecyclerView.
3)SnackBar - современная замена тосту. Дает возможность совершить действие. Удобен тем, что в отличие от тоста, встраивается в
иерархию вью и связан с приложением. Реализация похожа на тост, только онкликлистенер еще нужен.
4)ActionBar - теперь называется ToolBar. Toolbar - отдельный layout. Для него можно задать отдельную тему. Обычно включает
гамбургер-меню обычное меню и название. ActionBar до сих пор является частью активити, и чтобы тулбар стал этой частью вместо
экшнбара, применяется метод setSupportActionBar(): создается объект тулбара путем поиска по ид, и в этот метод передается ссылка
на этот объект. Далее, создается объект экшнбара путем присвоения методу getSupportActionBar() без параметров. Это нужно, чтобы
можно было не использовать тему noActionBar.
5)Меню: XML-файлы меню помещаются в отдельную директорию menu в папке res. Для создания меню, требуется специальный инфлейтер для
меню MenuInflater. Для реализации меню требуются 2 метода: onCreateOptionsMenu(Menu menu, MenuInflater inflater){
super.onCreateOptionsMenu(menu, inflater);
inflater.inflate(R.menu.some_menu, menu);
MenuItem item = menu.findItem(R.id.settings_for_example)
}
и onOptionsItemSelected(MenuItem item){
//здесь через switch обрабатываются элементы меню
}
6)Floating Action Button - доступ к часто используемым действиям. Сложно подобрать применение, узкое применение. Обычная кнопка
Что встроено уже в кнопку из коробки: если вызовется SnackBar, то кнопка автоматически поднимется вверх, но не перекроется
снэк-баром.
CoordinatorLayout: очень мощная штука, с которой работают все дизайн-вьюшки. Он координирует поведение вьюшек.
не нужно писать сложный код, делать кастомные вью, прописывать колбэки, связки этих вью и т.д.
2 задачи: закрепление вью с помощью якорей. Он может перехватывать касания, дизэйблить вьюшки, менять фон под вьюшками,
перехватывать прокрутку(например при прокрутке RecyclerView).
Использование якорей: атрибут app:layout_anchor="здесь_айди_какого_то_элемента_за_которым_идет_закрепление"
app:anchorGravity="bottom|end|right" - соответсвенно закрепляется внизу справа в конце.
Использование Behaviour: - для каждой вью поведение. Координатор проходит всю иерархию вью и находит все их поведения.
Behaviour - это специальный абстрактный класс. Проверяет их события. В этом классе определяется множество методов, позволяющих
реагировать определенным образом на те или иные действия вью.
Чтобы создать свой класс поведения. нужно наследоваться от этого абстрактного класса и в параметризованном типе указать
тип обрабатываемой вью.
Есть стандартные: ScrollingViewBehaviour - увеличение или уменьшение экшн-бара при скролле(и не только)
SwipeDismissBehaviour - уничтожение элемента при свайпе влево-вправо
BottomSheetBehaviour - вью изначально на экране нет, но если потянуть снизу, то она появится) Для диалог-фрагментов обычно
используется.
У поведений есть один большой недостаток: бехавиоры вызываются в главном потоке, колбэки вызывающиеся на каждой вью.
Если делать поведения, должно быть очень мало несложной логики и ничего нельзя в них ждать!!! Иначе, UI Thread забьется нафиг!
Переходить на новые версии дизайн лайбрари нужно переходжить только по мере необходимости!!!
Про CoordinatorLayout нужно читать отдельно! Нужен будет по-любому!
Элементы паттернов навигации:
1)TabLayout - навигация по горизонтали. Не рекомендуется уже, несмотря на то, что он новый. рекомендуется заменить на Bottom
Navigation. Только если элементов от 2 до 5. Добавление: создается TabLayout объект, добавляются табы методом addTab и
вешается таблистенер.
BottomNavigationView - то же что и табы, только внизу экрана, и вместо табов - кнопки. Через ФрагментМенеджер, например, менять
по нажатию кнопок фрагменты. XML-файл для этого BottomNavigationView берется из подпапки меню. На него вешается специальный
слушатель setOnNavigationItemSelectedListener(new BottomNavigationView.onNavigationItemSelectedListener){
//и тут с помощью switch пишем разную логику для разных кнопок, все здорово
}
у FragmentManager есть еще ChildFragmentManager, нужны при двойной навигации.
NavigationDrawer - появляется при нажатии на гамбургер-меню. Делится на 2 части: HeaderView и меню(список секций). Инициализируются
как меню. Вместо HeaderView можно влепить RecyclerView. Меню в NavigationView должны быть в группах.
Тулбар настраивается след.образом: вызывается метод setHomeButtonEnabled() включает кнопку, setHomeAsUpIndicator(R.drawable.ic_menu)
При нажатии срабатывает onOptionsItemSelected.
с помощью тега <include> можно вставлять одни хмл-файлы в другие. CollapsingToolbarLayout - этот layout тулбара, но реагирующего
на какие-либо действия, например,скролл.


*
*
* */
public class MaterialDesign {

}
