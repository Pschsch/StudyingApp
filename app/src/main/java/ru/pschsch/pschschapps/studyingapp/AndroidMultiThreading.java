package ru.pschsch.pschschapps.studyingapp;

import android.app.Activity;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.v7.app.AppCompatActivity;
import android.widget.TextView;

/********************************Здесь инфа из технострима по мультипоточности*****************************************************/
/* Handler: позволяет работать с Message Queue. Помещает сообщение в очередь и назначет самого себя в качестве получателя
этих сообщений. Если выполнять какие-либо действия в UI потоке, то приложение будет работаь, но UI поток перестанет обновляться,
что приводит к условному зависанию приложения. Условное оно потому, что приложение работает, но UI приложения не обновляется.
По прошествии определенного времени, ориентировочно 3-4 секунды, система предлагает закрыть приложение. Такая ошибка назывеатся
 ApplicationNotResponding. Вот для избежания такого
рода ситуаций и нужен Handler. Так как работа с View-элементами обеспечивается только основным потоком, то при попытке просто
вынести долгие и сложные задчи в другой поток, приложение крашнется с ошибкой, так как кастомный поток не имеет доступа к
элементам экрана. Handler - это мост между UI потоком и другими потоками, обеспечивающий обновление экрана исходя из действий
других потоков. Дополнительные потоки передают сообщения в MessageQueue, а из MessageQueue Handler извлекает сообщения и проводит
определнные действия в UI потоке.
Ключевое отличие процессов от потоков: процессы не пересекаются друг с другом в процессе одновременного выполнения: каждый процесс
имеет свою память, в случае потоков - они используют shared memory, следовательно могут взаимодействовать и влиять друг на друга.
* отсюда возникает главная проблема при работе с потоками - поточная безопасность данных. Углубимся в устройство потоков:
* Каждому потоку выделяется свой стек памяти, но работают они при этом с одной кучей, что укладывается в основное понятие потоков.
* Потоки выполняются одновременно, на каждый поток выделяется свой квант времени ЦП. Очень важно грамотно подобрать количество потоков
* При малом количестве процессорных ядер, ядра ЦП постоянно переключаются между потоками, стараясь, грубо говоря, "всем угодить",
* при этом большое количество таких операций весьма трудоемко. Если, например, добавить в приложение 1000 потоков, производительность
* такого приложение будет гораздо ниже, чем однопоточное такое же приложение. Многопоточность нужно реализовать строго по мере
* необходимости, в зависимости от трудоемкости задачи. Как работать с потоками в Java мы с знаем. Чтобы обеспечить безопасность
* данных при работе нескольких потоков, потоки должны быть синхронизированы. Это методы wait() notify() notifyAll()
* ключевое слово synchronized, join,  Классы и методы пакета java.util.concurrent. Синхронизация работает с помощью монитора, котоырй
* позволяет определять очередность работы с данными для потоков. Все объекты могут работать с этим монитором, так как wait
* notify notifyAll - методы из класса Object. Для грамотного использования synchronized кода, количество самого кода и данных,
* которыми он оперирует должно быть минимально. join() позволяет присоединиться к следующему потоку.
* wait notify notifyAll должны вызыватсья из синхронизированной секции кода. wait "усыпляет" поток, notify "будит".
* Переводят потоки в разные состояния. Всего 4 состояния: выполняющийся, возобновленный, заблокированный, завершенный.
* wait переводит в заблокированный, notify в возобновленный. Если поток попадает на метод wait, то другой поток, работающий с заданным объектом,
* сможет работать с ним, и как только другой поток дойдет до notify, заблокированный поток сможет продолжить свою работу.
* UI thread Android: UI thread - поток, отвечающий за отрисовку активностей. По сути, своего рода метод main, то есть основной поток.
* UI thread, как было сказано выше, единственный имеет доступ к элементам UI. Для этого нужно связвать UI поток с другими потоками
* UI работает с очередью сообщений, обрабатываемой Looper. Looper - бесконечный цикл, вытаскивающий сообщения из Message Queue
* По поводу Handler: на самом деле, Message Queue является мостом между background-потоками и UI-потоком, просто Handler организовы-
* вает рабоут с этой очередью. Доступ к Message Queue д/б синхронизирован, чтобы избежать изменения сообщения при вытаскивании или
* помещении его в очередь.
* 4 основных способа, которые Google предоставляет для работы с многопоточностью:
* View.post(Runnable run)
* Activity.runOnUiThread(Runnable run)
* Handler
* AsyncTask
* Существует множество оберток над ними.
* View.post(Runnable run) - метод post создает Java поток для работы с View. В Runnable, переданном в качесвтве параметра реализуется
* метод run.
* В каждом методе рабоытс вьюшками в Android SDK предусмотрена проверка на то, в каком потоке производится работа над ними.
* Если это не UI поток, то бросается исключение.
* 1)View.post(Runnable r) - простейший способ изменить View не из main потока. Данный способ является потокбезопасным, то есть
* функционирует правильно во время выполнения нескольких потоков. Создастся сообщение для MessageQueue, которое в последствии
* будет обработано Looper-ом и изменит UI. Для одной View
* 2)Activity.runOnUiThread(Runnable r) - похож на 1 способ, делает то же самое. Его стоит использовать, когда необходио работать
* с несколькими View на Activity, например обработать клик кнопки и присвоить текст TextView. Для нескольких View
* 3)Handler - традиционный интсрумент работы с background-потоками. Первые 2 способа работы с UI потоком из других потоков основаны
* на вызове Handler. Handler привязывается к Looper-у рабочего главного потока. Handler считывает сообщения из очереди сообщений
* и передает Looper-у. Основной метод Handler - handleMessage, в который передаются интсрукции для работы с UI из background-потоков
* Далее Looper возвращает сообщение Handler-у, и тот уже отрабатывает это сообщение
* 4)AsyncTask - обобщение первых трех методов. Работает также на хэндлерах и обычных Java-потоках. У него есть callback-и
* на фоновый поток и на UI-поток.
*
* View.post пример ниже, Activity.onUiThread работает также, только вызывает его текущий контекст
* вместо View
* Handler:
* Пример без обязательных деталей типа onCreate и пр
* protected void onCreate(///){///}
* ClassThread ct = new ClassThread;
* Thread tr = new Thread(ClassThread)
* ///
* ClassThread overridim tipo///
* ///
* В методе run создается экземляр Handler-а
* @Override
* public void run(
* //Handler-у передаются сообщения класса Message - это стандартный тип объектов сообщений MessageQueue.
* В методе run созданный экземпляр Handler-а работает с методом handleMessage, который можно настроить через оператор switch
* для отрабатывания определенных интсрукций. Созданный экземляр хэндлера принимает объект анонимного класса(как вариант),
* реализующего интерфейс Handler.Callback. Этот интерфейс и содержит как раз метод handleMessage. Метод типа boolean.
* Метод принимает на вход объект типа Message.
* Такой подход предпочтителен для относительно сложных преоктов.
*
* AsyncTask - он создан для упрощения работы в работе с многопоточностью.
* Содержит 4 основных метода: onPreExecute() - подготовка данных
* doInBackground(Params params) - выполнение основной работы - выполняется в UI потоке
* onProgressUpdate(Progress progress) - передает статус выполнения задачи(например)
* onPostExecute(Result result) - выполняется после окончания выполнения фоновой операции
* Сам класс AsyncTask является обобщенным, и принимает 3 типа <Params, Progress, Result>.
* Обяазтельный метод только doInBackground.
* Главный недостаток AsyncTask - он может применяться только в в не очень крупных проектах. Например, есть десяток, или даже
* больше фоновых операций, работающий с сетью, работающих с UI, работающий с базой данных, например, и , если использовать
* AsyncTask, количесвто этих тасков заметно растет, необходим один класс на операцию, что приводит к существенному загрязнению кода
* Поэтому, в крупных проектах, он не пойдет, хотя достаточно прост в использовании.
* Наиболее распростаненный инструмент работы с многопоточностью - пулы потоков, позволяющие перезапускать потоки, чтобы не создавать новые
* Это существенно позволяет оптимизировать приложение.
* Loader - инструмент асинхонной загрузки Activity и фрагментов. Один экземпляр LoaderManager для Activity и фрагментов.
* Loader получает callback-и при изменении состояния активити, он сильно сопряжен с жизненным циклом активностей и фрагментов.
* Loader - расширенный вид instanceState. Очень гибкий интсрумент.
* DeadLock - ситуация, в которой 2 потока друг друга блокируют.
* RaceCondition - ситуация, в которой данные не защищены от воздействия нескольких потоков, и они начинают изменять по своему
* данные, даже в момент использвоания данных другим потоком.
* java.util.concurrent: нужно подробно изучить в Шилдте - реализация блокировок потоков при чтении и записи - основная функция
* В тестах активно используется, нужно знать назубок!
*
*
*
* )
*
*
*
*
* */

public class AndroidMultiThreading extends AppCompatActivity {
    TextView tv;
    @Override
    protected void onCreate(Bundle onSavedInstanceState){
        super.onCreate(onSavedInstanceState);
        setContentView(R.layout.activity_inf);
        tv = new TextView(this);
        tv = findViewById(R.id.textView);

    //    Thread t = new Thread(RunnableClass);
    //    t.start();
    }
}
class RunnableClass implements Runnable{
    @Override
    public void run(){
        Message mes = new Message();
        Handler handler = new Handler(new Handler.Callback() {
            @Override
            public boolean handleMessage(Message msg) {
                return false;
            }
        });

    }
    }





