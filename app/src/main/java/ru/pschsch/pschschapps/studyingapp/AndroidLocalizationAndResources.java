package ru.pschsch.pschschapps.studyingapp;
/************************************Инфа по работе с ресурсами и Unit-тестами*****************************************************/
/*На данный момент число форматов экранов устрйоств очень велико. Приложение должно хорошо выглядеть везде.
* Термины: размер экрана, плотность экрана, ориентация, разрешение, dp.
* Разрешение играет гораздо меньшую роль, чем плотность.
* ldpi - 120dpi  mdpi - 160 dpi, hdpi - 240dpi, xhdpi - 320 dpi, xxhdpi - 480 dpi, xxxhdpi - 640 dpi . Android Studio, например,
* автоматом генерит иконки для разрешений от mdpi до xxxhdpi. Размеры экранов вычисляются в dp,  у каждого экрана - разное
* соотношение dp.
* Единицы измерения: самые ходовые dp и sp. sp учитывает параметр масштаба. sp часто используется для текста, если в настрйоках
* пользователь поставит размер шрифта свой.
* Квалификаторы: языки для папок values, плотность экрана для папок drawable
* Vector Drawable - векторные изображения. Огромное количество плюсов, которые мы уже узнали на
* практике. Но, это более дорогая операция в плане производительности, но не критично.
* В основном из них рисуются примитивы.
* 9.png - формат, который включал в себя элементы векторов. Сейчас не используются.
* Поддержка разных экранов:
* Использование фрагментов
* Использвоание разных картинок
* Использование векторов
* использовать sp только для текста
* использовать dp
* SupportsRtl - это специальный параметр, который инвертирует интерфейс слева направо для арабских пользователей.
* Стили и темы: неявно относятся к разным типам экрана.
* Темы - красота, единообразие, легкость в настройке и поддержке, возможность менять.
* Темы основаны на стилях: параметры: colorPrimary, colorPrimaryDark, windowBackGroud,
* navigationBarColor(если кнопки навигации на экране, а не физические), textColorPrimary.
* Android Studio предоставляет Theme Editor. Работает со styles.xml
* Темы можно наследовать. Стиль можно применять для разных элементов UI. Тема накладывается
* целиком на приложение. Дневная и ночная темы стоят по умолчанию.
* Вариант работы предпочтительный MODE_NIGHT_AUTO.
* Стили: почти то же самое, что темы, но стили можно применять к конкретному элементу.
* Стиль наследуется от другого стиля, путем определения в теге parent ссылки на стиль-родитель.
* При этом у дочернего стиля будут применены все атрибуты стиля-родителя.
* Большинство атрибут вьюшек можно переопределять в других стилях
* *********************************************************************************************
* Тестирование: аиболее широко используемый вид тестирования - Unit-тесты.
* Для чего нужны: 1)Проверка ошибок и защита кода от ошибок других. 2)Ускоряет разработку
* 3)Чтобы избежать неявных изменений в работе приложений. 4)Чтобы сократить цикл разработки
* 5)Чтобы "было".
* Есть практика использования TDD - это разработка через тестирование. По этой концепции
* пишется сначала тест, а под него уже код, потом это код рефакторится. Когда код покрывается
* тестами, очень четко и быстро формируются требования к коду, и за счет этого, несмотря на большее
* количество действий, разработка может ускоряться. Особенно важно при росте проекта, при каких-то
* изменениях, уже написанные тесты будут давать гарантию, что код работает так как надо.
* Что скоращает время отладки и поиска багов.
* Недостаток: нужно написать эти тесты и изменять их в процессе роста проекта. Тесты поддерживать
* тяжело. Поддержка TDD - тяжелый труд.
* 2 типа тестов: обычные JUnit тесты и непосредственные тесты на устройстве или эмуляторе
* JUnit тесты составляют примерно 70% в идеальном проекте. Остальные 30% это уже реальная
* работа  приложением. Их должно быть немного, так как очень трудоемки по времени.
* Для крупных проектов, несмотря на все сложности, рекомендуется.
* Для создания тестирования необходимо использовать JUnit library.
* Тестируемый метод помечается аннотацией @Test . Имена методов - любые, главное - аннотации.
* Также, в JUnit есть аннотации @Before @BeforeClass @After @AfterClass. @Before перед запуском теста
* @BeforeClass перед запуском пака тестов. @After и @AfterClass соответсвенно после выполнения тестов.
* Каждый Unit-тест должен содержать Assert - инструмент для верификации результатов, утверждение.
* Assert олжен верифицировать только одну какую-то операцию.
* Unit-тесты на устройстве(instrumentation tests): 1)библиотека Robolectric - симлирует реальное Android-окружение, что позволит
* теститровать контексто- зависимые вещи, UI е получится тестировать. Приложение для тестирования запускается поверх приложения.
* Контекст тестового приложения
* отедльный контекст, так как приложение другое. У тестового приложения свой package name.
* Чтобы достать правильный контекст, того приложения. которое тестируется, нужно вызвать метод getTargetContext().
* Тестирвоание активностей и сервисов: для тестирования Activity и Service предусмотрены специальные Rules в системе unit-тестов.
* За тестирование Activity отвечает ActivityTestRule
* За тестирование сервисов - соотвественно ServiceTestRule.
* Rule - расширение, поддерживаемое JUnit, содержащиее определнные методы дял проведения тестирования. Rule дополняет эти методы
* тестирования применимо для элемента Андроид-фреймворка. Использвоание Rules идет через Intent.
* ActivityTestRule параметризован типом активити, которое тестируется. Тесты запускаются в отличном потоке от UI потока.
* Для работы с UI через метод ruuOnUiThread на Handler-е.
* Для сервисов - ServiceTestRule, связатиься можно, если эжто bound service, через aidl-нтерфейс.
* Правила помечаются аннотацией @Rule
* В рамках одного тест-класса тестируется только один компонент приложения: одну активти, один сервис и т.д. т.е один класс-
* одно правило.
* Espresso: тестирование пользования UI. Работает с простыми вью, с RecyclerView. Реализует паттерн билдера. Все очень здорово.
* Что можно делать: искать вью по ид и свойству, эмулирвоать клик, ввод, скролл, проверять наличие текста, детей, интенты и их
* содержимое, веб-вью.
* UIAutomator - deprecated, более тяжелый чем Espresso.
* Mockito - библиотека, позволяющая эмулировать ответы сервера(mocks), чтобы проверять, что действительно наше какое0то действие
* корректно отрабатывает какой-то конкретный ответ от сервера.
* */

public class AndroidLocalizationAndResources {
}
