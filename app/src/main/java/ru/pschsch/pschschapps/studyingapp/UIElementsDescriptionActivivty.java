package ru.pschsch.pschschapps.studyingapp;
/*В анном классе будет происходить описание все элементов UI и соответсвующего им кода.
* При разработке android, можно устанавливать UI элементы как через код, так и через XML.
* XML работает через java-код. конкретно через класс R, в котором назначаются все атрибуты.
* 1)Любой метод для назначения свойства при выполнении какого-либюо действия начинается на
* setСвойство(View объект).
* Всякая нужная инфа:
* 1) Элементы ресурсов могут соджержать в своем названии только строчные латинские символы и цифры
* от 0-9.
* 2)ViewGroup - группа вьюшек. К ним относятся Layout, ScrollView. Т.е это контейнеры для
* простых View, с какими-то заданными свойствами отображения этих View.
* 3)В методе setContentView можно указать любой файл layout, для этого нужно лишь поменять
* идентификатор, определнный в классе R.
* 4) В XML-разметке каждая вьюшка соответсвует своему java-классу, ее параметры - это переменные
* с ее класса.
* 5) Нельзя использовать hardcoded string, нужно брать из ресурсов, так как, если какое либо слово
* нужно будет поменять, то оно поменяется везде, плюс это неправильная кодовая практика. Также
* удобно при локализации приложения. Также, их необходимо использоваться для избегания проблем
* с отображением текста из-за кодировки.
* 6)При создании разметки для landscape-ориентации, проще создать папку с xml-разметкой для
* всех активностей в landscape-разметке.
* 7)android: - обозначение пространства имен Android в XML-разметке.
* Атрибуты RelativeLayout(подходят для Constraint!!!)
* match_parent - максимально возможное занимаемое место в пределах родителя. НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ
* В CONSTRAINT LAYOUT. Вместо него использовать match_constraint(0dp).
* wrap_content - определение ширины и высоты, в зависимости от содержимого элемента.
* layout_height - высота
* layout_width - ширина
* android:id - id из класса R
* android:weight - вес, параметр, при значении которого ==1, элемент получает все свободное пространство
* родителя относительно других элементов. Единицы имерения веса - это пропорции, например, чтоы
* в разметке LinearLayout один элемент занимал 3/4 родителя, а другой 1/4 - то вес первого
* д/б равен 3, а вес второго равен 1.
* android:gravity - гравитация, выравнивание относительно границ вью-группы(с constraintLayout
* этот параметр не нужен)
* margin - отступы, также не нужен)
* Класс R создается Gradle-ом. При создании вьюшки, в android:id прописывается:
* @+id/myId - + означает, что данный id новый и будет добавлен в класс R.
* Гайд по TableLayout - похож на LinearLayout, только его строки состоят из ячеек. Эти строки
* называются TableRow - они являются вью-группами, располагающие в себе элементы по горизонтали.
* В отличие от Linear, где на одну строку приходится одна вью. Ширина столбца определяется
* по самому широкому элементу в столбце.
* dp - Density-Independent Pixels - абстрактная величина, необходимая для корректного отображения
* элементов на устройствах с любыми экранами. Отображение меняется в зависимости от категории
* экрана, а не от точного значения плотности. примерно соответствует одному пикселю на экране
* с плотностью 160ppi.
* sp - Scale-Independent Pixels - аналог dp, но еще зависит от шрифта текста.
* Гайд по ConstraintLayout: разметка, основанная на ограничениях(продвинутый аналог RelativeLayout)
* При перетаскивании любого элемента в эту вью-группу, ide жалуется на отсутсвие
* установленных ограничений для этого элемента. Говорит, что элемент поплывет в левый
* верхний край. Кружочки по бокам предназначены для привязки элемента к родителю(т.е к
* вью-группе ConstraintLayout). После привязки подсвечивается серым цвветом цифра - это
* величина отступа от границ родителя, т.е разметки. Привязку можно делать также и к другим
* элементам View. Например, чтобы imagebutton был привязан к TextView. При перемещении TextView
* ImageButton также будет перемещаться вместе с ним, так как его расположение связано с располо-
* жением TextView. ПРИВЯЗКА К ДРУГИМ ЭЛЕМЕНТАМ ПОЗВОЛЯЕТ РОВНО ОТОБРАЗИТЬ ИХ ОТНОСИТЕЛЬНО ДРУГ ДРУГА.
* Удалить привязку монжо при нажатии на кружок, либо по специальной подсвечивающейся кнопке.
* Привязка может быть как одностороняя(линии), так и двухсторонняяя(пружинка).
* Если например привязать TextView к кнопке с одной стороны, а с другой стороны к родителю, то
* При перемещении кнопки, ТекстВью будет оставаться ровно посередине между границей родителя
* и краем кнопки при условии отсутствия отступов. При двусторонней привязке отобращается скролл
* со значениями от 0 до 100. 0 - это самый левый край, 100 - самый правый край. По умолчания
* стоит 50 - значение, равное половине пути между 2-мя объектами, к которым привязано вью.
* Работа с View с помощью java-кода
* При работе с Java, для начала к объекту View необходимо привязать id вьюшки, с которой нужно
* работать через метод findViewById(R.id.myId);, где myId - ссылка на id вьюшки в классе R.
* Метод setText("someText") - метод сеттит введенный в аргументах метода текст во вьюшке
* Метод setEnabled(boolean enabled) - применяется для кнопок, при значении false - кнопка
* становится неактивной.
* Метод setChecked(boolean checked) - применяется для чек-бокса. При значении true, галочка
* в чек-боксе автоматически становится нажатой.
* Обработчики кликов: существует 3 способа: стандартный: 1)с помощью слушателя нажатий
* onClickListener(): для того, чтобы им воспользоваться, необходимо для кликабельного объекта
* применить метод setOnClickListener(new View.OnClickListener) - для кликабельного объекта
* применяется реализация интерфейса onClickListener. onClickListener находится
* в классе View, поэтому нужно прописывать к нему путь обязательно включив View. Данный
* интерфейс содержит в себе метод onClick(View view) - он переопределяется обязательно, как
* и все методы во всех интерфейсах в Java. Он содержит в качестве параметра объект типа View -
* это объект, к которому будет применен данный метод.
* 2)С помощью имплементации этого интерфейса в самой Activity, в этом случае обработчиком будет
* не новый объект, а сама активность. Для реализации обработчика используется также
* setOnClickListener(this), но в качестве параметра идет объект активности, его можно обозначить
* с помощью ключевого слова this.
* 3)Задача параметра onClick во вьюшке. Самый большой недостаток - нужны постоянно разные имена
* методов, что рушит полиморфизм. Также не работает во фрагментах!!!Лучше 1-й способ!.
* Обработчик для нескольких нажатий: реализуется с помощью оператора switch: на вход оператору
* switch подается метод (view.getId()), применяемый к объекту view класса View из метода
* onClick(); выглядит примерно так:
*  View.OnClickListener listener = new OnClickListener{
* public void onClick(View view){
*     switch(view.getId()){
*         case R.id.MyId1:
*         //some code
*         break;
*         case R.id.MyId2;
*         //some code
*         break;
*     }
* }
* }Важно: в данном методы нужно обращаться к ресурсам через класс R, например:
* R.string.someStr
* Применяется обработчик через метод setOnClickListener(listener), где в сигнатуре - объект
* обработчика.
* Параметр android:clickable - при значении true, View-элемент становится способным обрабатывать
* нажатия(Даже TextView!!!!!). Если на вьюшку назначить обработчик, этот параметр автоматически
* становится true.
* Ресурсы в Android: разделяются на значения и файлы.
* Структру аресурсов в Android-проекте: разные ресурсы хранятся в разных каталогах:
* animator и anim - ресурсы для работы с анимацией
* drawable - ресурсы картинок: jpeg, 9.png, png, gif
* assets и raw - любые ресурсы с любым расширением, поддерживаюшися платформой Android.
* setImageDrawable - метод позволяет применить к ImageView изображение. Такой способ подстановки
* изображения через java-код отлично подходит, если нужно будет поменять картинку при, анпример,
* нажатии кнопки.
* Сигнатура метода включает в себя(getResources().getDrawable(R.drawable.имя_файла))
* Логи: 5 уровней: v,i,d,e,a(по возрастанию)
* Toast Notification - всплывающие поверх Activity сообщения(а-ля "заполните все поля")
* Нужная вещь. Как использовать:
* Нужно создать экземпляр класса Toast:
* Toast someToast = Toast.makeText(this,"Some Message",LENGTH_SHORT);
* someToast.show();
* метод makeText заносит соответсвенно текст в объект Toast, первый параметр - это Activity, в которой
* метод работает, если метод прописан и используется в одной и той же активности, просто this,
* второй параметр - это выводимое сообщение, третий параметр - это duration показа сообщения
* LENGTH_LONG - 3,5 s; LENGTH_SHORT - 2 s  соответсвенно.
* Метод show() выводит сообщение на экран. По умолчанию, тост появится внизу экрана, чуть выше
* самого низа экрана. Для того, чтобы изменить местоположение сообщения при выводе, необходимо
* задать метод setGravity(Gravity.CENTER,0,0) - в качестве параметра метода выступает значение,
* которое гооврит о том, где необходимо высветить сообщение, в данном случае, при применении
* данного метода сообзение высветится в центре экрана. Второй и третий параметры - смещения
* по оси х и оси у соответственно
* Меню - прописывается в файле menu.xml. Файл разметки меню содержится в отдельной папке menu
* в папке res.
* Контекстное меню - выбор вариантов ответа(похоже на spinner). Задается с помощью метода
* registerForContextMenu(экземпляр_View). В качестве такого эземпляра может выступать например
* TextView. Далее, после регистрации контекстного меню вызывается метод
* onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo)
* Создается через оператор switch, в case-ах указываются добавочные пункты меню, при выборе
* какого-либо компонента контекстного меню. Далее, чтобы реализовать уже какие-либо действия
* используется метод onContextItemSelected, которому на вход подается id выбранного item'a
* через (item.getItemId());. Метод onCreateContextMenu работает через слушатель контекстного
* меню, который прописан в классе Activity. Слушателю на вход идет параметр this, то есть
* обработчиком контекстного меню является Activity(можно зайти в source-code класса Activity);
* СОЗДАНИЕ ЭЛЕМЕНТОВ ЭКРАНА БЕЗ ПОМОЩИ XML(ВСЕ ЧЕРЕЗ JAVA-КОД) создан пример проекта в
* приложении OnlyJava
* RadioButton и RadioGroup - радиокнопки. Особенность их в том, что они не используются по отдельности.
* Их должно быть минимум две, и одна из этих кнопок в радиогруппе должна быть выбрана. По сути
* переключатель: при выборе другого, выключается первый. RadioGroup - контейнер для RadioButton.
* Чтобы задействовать RadioButton к каждому переключателю необходимо применить слушатель
* OnClickListener, как и к другим кликабельным объектам. Для использования кнопок из радиогруппы
* необходимо использовать getCheckedRadioButtonId(), который возвращает радиокнопку из
* радиогруппы. Метод применяется к созданному экземпляру класса RadioGroup.
* Метод RemoveAllViews() - удаляет все View с выбранного экземпляра контейнера. Например,
* с ConstraintLayout. При применении метода к его экзепмляру, все View с этой разметки будут
* удалены.
* SeekBar - ползунок. Имеет 2 отличительных свойства - максимальное и текущие значения.
* В качестве обработчика выступает интерфейс onSeekBarChangeListener класса SeekBar.
* Содержит 3 метода: onStartTrackingTouch() onStopTrackingTouch() и onProgressChanged().
* В процессе начала движения ползунка срабатывает метод onStartTrackingTouch() и во время
* движения срабатывает onProgressChanged(). Когда мы бросаем ползунок, срабатывает
* onStopTrackingTouch().
* Анимация: описывается в файлах в директории anim внутри тега set: по мере необходимости, можно
* будет погуглить и узнать.
* Элементы MaterialDesign - использование VectorDrawables в Android.
* VectorDrawables находятся в формате XML. Атрибуты VectorDrawables:
* <vector> - обозначение элемента VectorDrawable
* Дочерние теги тега <vector>
*     android:tint - оттенок фигуры, по сути преобразуется в растровое изображение(плохо)
*     android:name - имя xml вектора
*     android:width и android:height - ширина и высота вектора(нужно указывать в dp!!!)
*     android:viewportWidth и height - пространство, относительно которого показано изображение
*     android:autoMirrored - булевское значение, если true, вектор инвертируется
*     android:alpha - прозрачность, максимум 1.0
* <path> - тело объекта
* android:pathdata - набор SVG команд, описывающий фигуру
* android:fillColor - заливка фигуры цветом. В отличие от SVG, XML-вектор может иметь строго
* определенный цвет, SVG поддерживает еще градиентную заливку.(начиная с api24 поддерживает)
* BackgroundTint - атрибут View, к которому применяется Vector Drawable
* Intent inf:
* Использование startActivityForResult - ввод данных в лругой активити и возврат данных
* в предыдущую. тобы вывести результат, нужно в начальном контексе вызвать метод onActivityResult.
* метод StartActivityForResult(Context context, int requestCode) - requestCode - это ключ,
* по которому будет понятно, что метод onActivityResult будет выполняться операции в изначальной
* activity из конкретной Activity
* Метод onActivityResult(int requestCode, int resultCode, Intent data){
* resultCode - это идентификатор успешного выполнения операции(код возврата)
* data - это Intent, из которого возвращаются данные. Для resultCode редусмотрены константы
* RESULT_OK и RESULT_CANCELLED - выполнен и не выполнен соответсвенно
* Метод setResult(int resultCode, Intent intent) - данный метод возвращает результат в Intent
* и при выполнении в начальной activity метода onActivityResult передается информация из Intent
* переданного в этот метод.
* }
* *********************************************************************************************
* URI:
* Explicit Intent меет атрибут action - желаемое действие. Атрибут data в explicit intent
* имеет тип URI. Universal Resource Identifier - строка, в которой прописана последовательность
* символов, идентифицирующая тот или иной ресурс по типу и адресу ресурса:
* Синтаксис объекта URI: тип:адрес
* Пример: tel:+79184951470 - tel - тип, +79184951470 - номер
* http://vk.com - http - тип, //vk.com - адрес и так далее. То есть тип и адрес разделяются двоеточием.
* Uri.parse("tel:+79184951470") - метод parse разбирает переданную ему строку на составляющие,
* согласно синтаксису объекта URI. Это наиболее простое представление объекта URI
* На самом деле, объект URI состоит из большего числа составляющих, определенный по тем или иным
* критериям. Представить его можно в виде тегов: <scheme>://<authority><path> например
* Любой объект URI всегда начинается с тега <scheme> или схема. По этому тегу определяется тип
* данных URI. Этот тип прописывается в intent-фильтрах в теге data. Теги data нужны для опредления
* какие именно теги URI объекта должны считываться активностью.
* *********************************************************************************************
* ХРАНЕНИЕ ДАННЫХ В ANDROID:
* Есть несколько видов хранения данных в андроид(исключая Java Collections Framework):
* 1)Preferences - данные хранятся в виде пары ключ-значение
* 2)SQLite - внутренние базы данных
* 3)Обычные файлы
* *********************************************************************************************
* SharedPreferences - чаще всего используется для сохранения каких-либо пользовательских параметров
* настроек и так далее.
* Сохранение данных в SharedPreferences: для начала нужно создать объект анонимного класса
* реализующего интерфейс SharedPreferences с помощью метода getPreferences:
* SharedPreferences sPref = getPreferences(MODE_PRIVATE). Параметр метода getPreferences -
* это int mode - способ доступа к SharedPreferences. ВСЕ, КРОМЕ MODE_PRIVATE ОБОЗНАЧЕНЫ КАК
* DEPRECATED!!!
* Для редактирования SharedPreferences используется экземляр интерфейса Editor. Создается
* с помощью метода edit(): можно использовать статический импорт, чтобы импортировать этот
* интерфейс из интерфейса SharedPreferences напрямую. Далее, уже идет работа непосредственно
* с экземпляром анонимного класса, реализующего этот интерфейс. Методами put добавляем данные,
* методом apply() сохраняем изменения.
* Загрузка данных из SharedPreferences: также создаем объект класса, реализующего SharedPreferences
* с помощью getPreferences. Для чтения, editor нам уже не нужен. И с помощью методов get
* получаем значения из SharedPreferences по ключу. Чтобы ввести автосохранение, нужно сделать
* сохранение в методе onDestroy(). Если посмотреть исходники интерфейса SharedPreferences,
* то видно, что метод getPreferences возвращает результат выполнения метода
* getSharedPreferences(getLocalClassName(),mode), которому в качестве аргумента передается
* результат выполнения метода getLocalClassName() - этот метод возвращает значение теккущего класса.
* Если вместо метода getPreferences() использовать getSharedPreferences() то можно указать имя
* файла, в котором будут сохраняться наши Preferences для доступа к ним из любой Activity.
* Preferences сохраняются в XML-файле в папке data с данными приложения на устройстве.
* *********************************************************************************************
* SQLite - это бесплатно распространяемая библиотека, предоставляющая возможность создавать
* внутренние БД без реализации функции клиент-сервер, работа с которой осуществляется с помощью
* языка запросов SQL. Она позволяет содержать огромный набор структурированных данных.
* ЛУЧШЕ ПОЧИТАТЬ О НЕЙ НА SQLITE.ORG!!!
* Типы хранимых данных в SQLite:
* TEXT - это символы в кодировке Unicode. По сути, аналог String в Java.
* INTEGER - целочисленное значение, аналог long в Java.
* REAL - плавающая точка, аналог double в Java.
* Есть еще типы NULL - пустое значение, NUMERIC - значения boolean и дата и время
* BLOB - бинарные данные.
* Но, прежде чем их сохранять в БД, их нужно конвертировать.
* Поля таблиц в SQlite декларативные, вне зависимости от того, какие данные вносятся в поле,
* SQLite сам определяет тип поля для них. Для того, чтобы избежать раного рода косячных ситуаций,
* лучше использовать только базовые типы данных SQLite. Для значений boolean ожно использовать
* 1 для true, 0 для false. Двоичные данные лучше сохранять в отдельных файлах, а в БД прописывать
* путь к ним.
* Работа с SQLite осуществляется через библиотеку Room, она напрямую связывает SQLite и Java.
* т.е является оберткой. Это решение из набора Android Architecture Components. Этот набор
* уже встроен в базовый SDK. Из этого набора идет понятие жизненного цикла Activity и фрагментов
* например. (позже)
* Room подключается к проекту в Gradle скриптах building-а приложения и проекта в модулях
* dependencies и repositories соответсвенно(подробнее о версии посмотреть на оф-сайте)
* (Об Android Architecture Components изучить информацию отдельно!)
* LayoutInflater: LayoutInflater позволяет создать View из заданных параметров в layout.
* Это делает метод inflate(). Реализаций его много, но результат всегда один - View
* Перевод названия метода, в принципе, соответсвует функции: он "раздувает" вьюшку параметрами
* с XML-файла
* Онда из реализаций ниже:
* public View inflate(int resource, ViewGroup root, boolean attachToRoot)
* Параметры этой реализации метода inflate: int resource - это id layout-файла из класса R,
* который будет использоваться для раздувания вьюшки, ViewGroup root - родительская
* ViewGroup для создаваемой View. LayoutParams от этой вью-групп присваиваются View.
* attachToRoot - определяет, присоединять ли создаваемую вью к root, если true, то вью
* становится дочерним элементом вью-группы root. Есл false, то только принимает layoutParams
* от root, но его дочерним элементом не становится
* LayoutInflater - интерфейс, соответсвенно, по аналогии с spref, нужно получить объект,
* реализующий эот интерфейс. Производится с пмоощью метода getLayoutInflater().
* LayoutInflater inflater = getLayoutInflater();
* Далее, после объявления объекта разметки, нужно вызвать метод inflate для раздувания вьюшки
* в нем: LinearLayout linLayout = new LinearLayout;
* View tvView = inflater.inflate(R.layout.xmlFileOfParentLayout, linLayout, true)
* linLayout - родитель вьюшки, так как attachToRoot - true
* Создание списка: ListView: при создании списка, можно просто через цикло for методом inflate в каждой итерации создавать
* View и передавать этой вьюшке параметры. Но , классический способ, это использование ListView. ListView - специальное View
* для создания списка, работающее по похожей схеме, описанной выше. Только, в ListView, элементы списка за нас создает адаптер.
* Адаптеру необходимы для успешной работы данные, которыми будет заполняться элемент списка и layout-файл пункта списка. Далее
* адаптер присваивается ListView. При построении, список запрашивает у адаптера пункты, адаптер их создает и возвращает списку.
* Итог: готовый список. Видов списков и адаптеров - много. ListView устарел))) вместо него используется RecyclerView,
* о нем и пойдет речь ниже. RecyclerView - это своего рода ListView2, его использование соответсвует стандарту Google Material
* Design. RecyclerView предоставляет более эффективную реализацию списка, разделяет зоны ответсвтвенности между классами.
* Для реализации ListView нужен был только адаптер. Для ListView, реализация происходила через класс ArrayAdapter. Классы
* адаптеров для списка - обобщенные, чтобы оперировать строками, то обобщенный тип должен быть String.
* Создание адаптера для списка ListView:
* ArrayAdapter<String> adapter = new ArrayAdapter<>(текущая_активити.this, R.layout.ElementOfListLayout, String[] strArr);
* то есть, адаптеру передаются параметры текущего контекста, файл разметки вьюшки, которой будет заполняться список и либо массив
* строк из strings.xml, либо массив строк прописанный в коде активности. Далее, адаптер присваивался к списку методом
* setAdapter(adapter), где в качестве параметра - созданный адаптер, а вызывающий объект - объект ListView. На этом работа со
* списками заканчивалась. Адаптер прогоняет файл разметки элемента списка через LayoutInflater и получает вьюшку, присваивает
* вьюшке текст из переданного файла. Для использования LayoutInflater адаптер использует переданный ему контекст.
* Теперь работа с RecyclerView: для работы с recyclerView используется похожий подход, только для своей реализации ему необходим
* LayoutManager. LayoutManager - специальный класс, отвечающий за внешний вид нашего списка. Есть встроенные менеджеры разметки,
* можно создавать и использовать сосбтвенные. В качестве примера, будет использоваться LinearLayoutManager. RecyclerView с
* присвоенным LinearLayoutManager - это, по сути, ListView.
* Для его работы также требуется адаптер. Специальный адаптер для RecyclerView определен как RecyclerView.Adapter.
* Данный адаптер использует для работы паттерн VIewHolder. Это специальный класс, позволяющий увеличить быстродействие и экономию
* ресурсов при использовании RecyclerView. Класс работает следующим образом: вместо того, чтобы при взаимодействии со списком
* постоянно вызывать findViewById(), который потребляет достаточно много ресурсов при работе с большими списками, View Holder
* содержит в себе все ссылки на вьюшки, используемые в списке. Таким образом, количество вызовов findViewById существенно сокращается
* Данный класс создается внутри класса адаптера как вложенный статический. Внутри этого статического класса объявляются наши
* вьюшки, которые будут использоваться в каждом элементе списка RecyclerView и ссылки на их айдишники через методы
* findViewById. Любой вью-холдер класс наследуется от RecyclerView.ViewHolder.
* Пример ViewHolder класса. Здесь пример для CardView, но суть та же
* public static class PersonViewHolder extends RecyclerView.ViewHolder {
        CardView cv;
        TextView personName;
        TextView personAge;
        ImageView personPhoto;

        PersonViewHolder(View itemView) {
            super(itemView);
            cv = (CardView)itemView.findViewById(R.id.cv);
            personName = (TextView)itemView.findViewById(R.id.person_name);
            personAge = (TextView)itemView.findViewById(R.id.person_age);
            personPhoto = (ImageView)itemView.findViewById(R.id.person_photo);
        }
    }
* Далее, конструктор этого класса добавляется в пользовательский адаптер. RecyclerView.Adapter содержит 3 абстрактных метода,
* которые нужно переопределить:
* 1)getItemCount - определяет количество элементов списка
* 2)onCreateViewHolder - раздувает вьюшки исзодя из настройки класса ViewHolder и возвращает ViewHolder, содержащий View
* 3)onBindViewHolder - указывает содержимое каждого элемента списка RecyclerView.
* И еще переопределяется метод onAttachedToRecyclerView(RecyclerView rv), который присваивает адаптер к RecyclerView.
* Реализация метода происходит из суперкласса.
* И последнее действие, как и в ListView, настроенный адаптер инициализуется как новый объект в активности и присваивается
* экземпляру RecyclerView через метод setAdapter.
* Для того, чтобы получить доступ к строкам из ресурсов, нужно использовать метод createFromResource
* Для множественного выбора есть режимы одиночного и множественного выбора, через метод setChoiceMode(mode_someMode)
* А для работы с выбранными элементами используется SparseBooleanArray из пакета android.util. Все SparceArray - это
* карты, в случае boolean ключ - это номер, а значение - true или false.
* События RecyclerView: нажатие - onItemClick(), выделение onItemSelect(), прокрутка onScroll()
* Для кждого события свой слушатель:  onItemSelectListener  и onScrollListener, но
* Каждый из этих слушателей переопределяет соответсвенные методы.
* ExpandableRecyclerView - для создания двухуровневого дерева-списка, испольуются 2 ViewHolder - parent и child.
* Для каждого из viewholder переопределяются методы onCreate и onBind, в первом случае для ParentViewHolder, во втором
* ChildViewHolder, а так приницп тот же.
* Адаптеры: мост данные-объект. Все адаптеры реализуют интерфейс Adapter. По мере надобности изучим
* Диалоги: высплывающие окна, которое используется для ввода небольшого ко-лва данных.
* 1)TimePickerDialog - диалог для задания времени
* 2)DatePickerDualog - диалог для выбора даты
* 3)AlertDialog - диалог предупреждения. При выполнении какого-либо действия, всплывает, с целью, например, подтвердить действие.
* Для вызова диалога по кнопке назад можно реализовать метод onBackPressed для реагирования на это действие.
* Метод onPrepareDialog - вызывается каждый раз перед вызовом диалога.
* 4)ProgressDialog - диалог, показывающий пользоваьелю прогресс выполнения того или иного действия. Бывают как просто
* с анимацией ожидания, так и с прогресс-баром. Для этого настраивается стиль диалога.
* Parcel: контейнер для передачи данных через Intent. Это типа коллекции для разных типов данных. Передает объекты с поддержкой
* Parcelable. Если понабодится, разберем позже
* onSaveInstanceState: коллекция типа Bundle, предназначенная для сохранения информации при повороте Activity. Метод
* onSaveInstanceState вызывается перед вызовом метод onPause, onRestoreInstanceState - перед вызовом onResume после уничтожения
* и создания новой активности. Для созранения данных, в этих методах прописываются все переменные, которые помещаются в объект
* Bundle. При повороте экрана можно передавать ссылки на объекты: с помощью методов onRetainNonConfigurationInstance и
* getLastNonConfigurationInstance
* Пакет android.preference: данный пакет предоставляет средствва для работы с настройками приложения. Главное средство -
* PreferenceActivity - специальная активность, абстрактный класс для реализации компонентов настроек. В XML-файле обозначается
* тегом <PreferenceScreen>. Этот пакет еще называют Preference Framework. Класс настроек наследуется от PreferenceActivity.
* XMLPullParser - парсер XML-документов по тегам и содержимому.
*
*
*
**/

import android.content.SharedPreferences;
import android.os.Looper;
import android.support.v7.app.AlertDialog;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.Adapter;
import android.widget.ArrayAdapter;
import android.preference.PreferenceActivity;
import android.widget.TextView;
import android.widget.Toast;

import java.util.LinkedList;
import java.util.List;

import static android.content.SharedPreferences.Editor;

public class UIElementsDescriptionActivivty extends AppCompatActivity {
    private final String KEY = "key";
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_uielements_description_activivty);
        SharedPreferences spref = getSharedPreferences("MySPref",MODE_PRIVATE);
        Editor ed = spref.edit();
        ed.putString(KEY,"value");
        ed.apply();
        RecyclerView view = findViewById(R.id.recyclerview);
        view.setLayoutManager(new LinearLayoutManager(UIElementsDescriptionActivivty.this));
        TextView tv = new TextView(this);
        tv.setText(R.string.app_name);
    }
    protected void onResume(){
        super.onResume();
    }
   /* public static class Viewholder extends RecyclerView.ViewHolder{
        Viewholder(){
        TODO
        }
    }*/
}
